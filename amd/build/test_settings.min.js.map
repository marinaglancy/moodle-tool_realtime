{"version":3,"file":"test_settings.min.js","sources":["../src/test_settings.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * JavaScript for the test settings page\n *\n * @module     tool_realtime/test_settings\n * @copyright  Marina Glancy\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Ajax from 'core/ajax';\nimport Config from 'core/config';\nimport * as PubSub from 'core/pubsub';\nimport RealTimeEvents from 'tool_realtime/events';\nimport {sendToServer} from 'tool_realtime/api';\n\n/** @type {number} Seconds without events before showing timeout warning */\nconst RECEIVE_TIMEOUT_SEC = 90;\n\nconst SELECTORS = {\n    root: '#tool-realtime-test-settings',\n    stat: (name) => `[data-stat=\"${name}\"]`,\n    action: (name) => `[data-action=\"${name}\"]`,\n    field: (name) => `[data-field=\"${name}\"]`,\n    region: (name) => `[data-region=\"${name}\"]`,\n};\n\n/** @type {Object} Stats for receive test */\nlet receiveStats = null;\n\n/** @type {Object} Stats for push test */\nlet pushStats = null;\n\n/** @type {number|null} Timer ID for receive timeout detection */\nlet receiveTimeoutId = null;\n\n/** @type {number|null} Estimated clock offset (server - browser) in ms, null if not yet calibrated */\nlet clockOffset = null;\n\n/** @type {number} Number of calibration round-trips */\nconst CALIBRATION_SAMPLES = 5;\n\n/**\n * Generate a unique burst identifier\n *\n * @return {string}\n */\nconst generateBurstId = () => Date.now().toString(36) + Math.random().toString(36).slice(2, 8);\n\n/**\n * Reset receive stats\n *\n * @param {string} burstid\n */\nconst resetReceiveStats = (burstid = '') => {\n    clearReceiveTimeout();\n    receiveStats = {\n        count: 0,\n        expected: 0,\n        totalLatency: 0,\n        min: Infinity,\n        max: -Infinity,\n        latencies: [],\n        errors: 0,\n        errorMessages: [],\n        seqReceived: new Set(),\n        burstid: burstid,\n    };\n};\n\n/**\n * Reset push stats\n */\nconst resetPushStats = () => {\n    pushStats = {\n        count: 0,\n        expected: 0,\n        totalRtt: 0,\n        min: Infinity,\n        max: -Infinity,\n        errors: 0,\n        errorMessages: [],\n    };\n};\n\n/**\n * Get the root element\n *\n * @return {HTMLElement}\n */\nconst getRoot = () => document.querySelector(SELECTORS.root);\n\n/**\n * Update a stat display element\n *\n * @param {string} name\n * @param {string} value\n */\nconst updateStat = (name, value) => {\n    const el = getRoot().querySelector(SELECTORS.stat(name));\n    if (el) {\n        el.textContent = value;\n    }\n};\n\n/**\n * Show a results region\n *\n * @param {string} name\n */\nconst showRegion = (name) => {\n    const el = getRoot().querySelector(SELECTORS.region(name));\n    if (el) {\n        el.classList.remove('d-none');\n    }\n};\n\n/**\n * Hide a results region\n *\n * @param {string} name\n */\nconst hideRegion = (name) => {\n    const el = getRoot().querySelector(SELECTORS.region(name));\n    if (el) {\n        el.classList.add('d-none');\n    }\n};\n\n/**\n * Show the reset button for a section\n *\n * @param {string} section\n */\nconst showResetButton = (section) => {\n    const el = getRoot().querySelector(SELECTORS.action(section + '-reset'));\n    if (el) {\n        el.classList.remove('d-none');\n    }\n};\n\n/**\n * Get field value\n *\n * @param {string} name\n * @param {number} defaultValue\n * @return {number}\n */\nconst getFieldValue = (name, defaultValue = 1) => {\n    const el = getRoot().querySelector(SELECTORS.field(name));\n    if (!el) {\n        return defaultValue;\n    }\n    const val = parseInt(el.value, 10);\n    return isNaN(val) ? defaultValue : val;\n};\n\n/**\n * Format milliseconds for display\n *\n * @param {number} ms\n * @return {string}\n */\nconst formatMs = (ms) => Math.round(ms) + ' ms';\n\n/**\n * Extract a readable error message from various error object formats\n *\n * Moodle Ajax errors can be plain strings, Error objects, or objects with\n * .message, .error, or .debuginfo properties.\n *\n * @param {*} err\n * @return {string}\n */\nconst extractErrorMessage = (err) => {\n    if (!err) {\n        return 'Unknown error';\n    }\n    if (typeof err === 'string') {\n        return err;\n    }\n    if (err.message) {\n        return err.message;\n    }\n    if (err.error) {\n        return err.error + (err.debuginfo ? ' (' + err.debuginfo + ')' : '');\n    }\n    return String(err);\n};\n\n/**\n * Add an error to receive stats and update the display\n *\n * @param {string} message\n */\nconst addReceiveError = (message) => {\n    if (!receiveStats) {\n        resetReceiveStats();\n    }\n    receiveStats.errors++;\n    receiveStats.errorMessages.push(message);\n};\n\n/**\n * Clear the receive timeout timer\n */\nconst clearReceiveTimeout = () => {\n    if (receiveTimeoutId !== null) {\n        clearTimeout(receiveTimeoutId);\n        receiveTimeoutId = null;\n    }\n};\n\n/**\n * Start or reset the receive timeout timer\n *\n * If no events arrive within RECEIVE_TIMEOUT_SEC seconds, records a timeout error.\n */\nconst resetReceiveTimeout = () => {\n    clearReceiveTimeout();\n    if (receiveStats && receiveStats.expected > 0 && receiveStats.count < receiveStats.expected) {\n        receiveTimeoutId = setTimeout(() => {\n            const missing = receiveStats.expected - receiveStats.count;\n            addReceiveError('Timeout: ' + missing + ' event(s) not received within ' + RECEIVE_TIMEOUT_SEC + 's');\n            updateStat('receive-status', 'Timeout (' + receiveStats.count + ' of ' + receiveStats.expected + ' received)');\n            updateReceiveDisplay();\n        }, RECEIVE_TIMEOUT_SEC * 1000);\n    }\n};\n\n/**\n * Update the adjusted latency column from raw latencies and current clockOffset.\n * Can be called after recalibration to refresh already-displayed results.\n */\nconst updateAdjustedDisplay = () => {\n    if (!receiveStats || receiveStats.count === 0) {\n        updateStat('receive-avg-adjusted', '');\n        updateStat('receive-minmax-adjusted', '');\n        return;\n    }\n    if (clockOffset === null) {\n        updateStat('receive-avg-adjusted', '');\n        updateStat('receive-minmax-adjusted', '');\n        return;\n    }\n    let total = 0;\n    let min = Infinity;\n    let max = -Infinity;\n    for (const raw of receiveStats.latencies) {\n        const adjusted = raw + clockOffset;\n        total += adjusted;\n        min = Math.min(min, adjusted);\n        max = Math.max(max, adjusted);\n    }\n    const avg = total / receiveStats.latencies.length;\n    updateStat('receive-avg-adjusted', formatMs(avg) + ' (adjusted)');\n    updateStat('receive-minmax-adjusted', formatMs(min) + ' / ' + formatMs(max) + ' (adjusted)');\n};\n\n/**\n * Update receive stats display\n */\nconst updateReceiveDisplay = () => {\n    showRegion('receive-results');\n    showResetButton('receive');\n\n    const countText = receiveStats.expected > 0\n        ? receiveStats.count + ' / ' + receiveStats.expected\n        : String(receiveStats.count);\n    updateStat('receive-count', countText);\n    updateStat('receive-errors', String(receiveStats.errors));\n\n    if (receiveStats.count > 0) {\n        const avg = receiveStats.totalLatency / receiveStats.count;\n        updateStat('receive-avg', formatMs(avg));\n        updateStat('receive-minmax', formatMs(receiveStats.min) + ' / ' + formatMs(receiveStats.max));\n\n        updateAdjustedDisplay();\n    }\n\n    if (receiveStats.errors > 0) {\n        showRegion('receive-error-details');\n        const el = getRoot().querySelector(SELECTORS.region('receive-error-messages'));\n        if (el) {\n            el.textContent = receiveStats.errorMessages.join('\\n');\n        }\n    }\n\n    if (receiveStats.expected > 0 && receiveStats.count >= receiveStats.expected) {\n        clearReceiveTimeout();\n        updateStat('receive-status', receiveStats.errors > 0 ? 'Complete (with errors)' : 'Complete');\n    }\n};\n\n/**\n * Update push stats display\n */\nconst updatePushDisplay = () => {\n    showRegion('push-results');\n    showResetButton('push');\n\n    const countText = pushStats.expected > 0\n        ? pushStats.count + ' / ' + pushStats.expected\n        : String(pushStats.count);\n    updateStat('push-count', countText);\n    updateStat('push-errors', String(pushStats.errors));\n\n    if (pushStats.count > 0) {\n        const avg = pushStats.totalRtt / pushStats.count;\n        updateStat('push-avg', formatMs(avg));\n        updateStat('push-minmax', formatMs(pushStats.min) + ' / ' + formatMs(pushStats.max));\n    }\n\n    if (pushStats.errors > 0) {\n        showRegion('push-error-details');\n        const el = getRoot().querySelector(SELECTORS.region('push-error-messages'));\n        if (el) {\n            el.textContent = pushStats.errorMessages.join('\\n');\n        }\n    }\n\n    if (pushStats.expected > 0 && (pushStats.count + pushStats.errors) >= pushStats.expected) {\n        updateStat('push-status', pushStats.errors > 0 ? 'Complete (with errors)' : 'Complete');\n    }\n};\n\n/**\n * Handle incoming realtime event for the receive test\n *\n * @param {Object} data\n */\nconst onEventReceived = (data) => {\n    if (data.component !== 'tool_realtime' || data.area !== 'test') {\n        return;\n    }\n    if (!receiveStats) {\n        return;\n    }\n\n    const payload = data.payload || {};\n\n    // Ignore events from a different burst.\n    if (receiveStats.burstid && payload.burstid !== receiveStats.burstid) {\n        return;\n    }\n\n    const now = Date.now();\n    const senttime = parseInt(payload.senttime, 10);\n    const seq = parseInt(payload.seq, 10);\n    const total = parseInt(payload.total, 10);\n\n    if (total > 0) {\n        receiveStats.expected = total;\n    }\n\n    // Validate payload has required senttime.\n    if (!senttime || isNaN(senttime) || senttime <= 0) {\n        addReceiveError('Event received with missing or invalid senttime: ' + JSON.stringify(payload));\n        updateReceiveDisplay();\n        return;\n    }\n\n    // Check for duplicate sequence numbers (only meaningful during burst tests).\n    if (receiveStats.expected > 1 && !isNaN(seq)) {\n        if (receiveStats.seqReceived.has(seq)) {\n            addReceiveError('Duplicate event received for seq=' + seq);\n        }\n        receiveStats.seqReceived.add(seq);\n    }\n\n    const latency = now - senttime;\n    receiveStats.count++;\n    receiveStats.totalLatency += latency;\n    receiveStats.min = Math.min(receiveStats.min, latency);\n    receiveStats.max = Math.max(receiveStats.max, latency);\n    receiveStats.latencies.push(latency);\n\n    updateStat('receive-status', 'Receiving...');\n    resetReceiveTimeout();\n    updateReceiveDisplay();\n};\n\n/**\n * Calibrate the clock offset between browser and server\n *\n * Sends CALIBRATION_SAMPLES AJAX requests and measures apparent one-way delays in each direction.\n * The server returns its midpoint timestamp, so processing time is split evenly.\n * offset = (avgToServer - avgFromServer) / 2 estimates the server-browser clock difference.\n *\n * @return {Promise<void>}\n */\nconst calibrateClockOffset = async() => {\n    const infoEl = getRoot().querySelector(SELECTORS.region('calibration-info'));\n    if (infoEl) {\n        infoEl.textContent = 'Calibrating...';\n    }\n    const recalibrateLink = getRoot().querySelector(SELECTORS.action('recalibrate'));\n    if (recalibrateLink) {\n        recalibrateLink.classList.add('d-none');\n    }\n\n    const timeUrl = Config.wwwroot + '/admin/tool/realtime/time.php';\n    const toServerSamples = [];\n    const fromServerSamples = [];\n\n    for (let i = 0; i < CALIBRATION_SAMPLES; i++) {\n        try {\n            const t1 = Date.now();\n            const response = await fetch(timeUrl);\n            const t4 = Date.now();\n            const text = await response.text();\n            const t2 = Math.round(parseFloat(text) * 1000);\n\n            if (t2 > 0) {\n                toServerSamples.push(t2 - t1);\n                fromServerSamples.push(t4 - t2);\n            }\n        } catch (err) {\n            window.console.warn('Clock calibration sample failed:', err);\n        }\n    }\n\n    if (toServerSamples.length === 0) {\n        if (infoEl) {\n            infoEl.textContent = 'Clock calibration failed.';\n        }\n        return;\n    }\n\n    const avgToServer = toServerSamples.reduce((a, b) => a + b) / toServerSamples.length;\n    const avgFromServer = fromServerSamples.reduce((a, b) => a + b) / fromServerSamples.length;\n    const estimatedOffset = (avgToServer - avgFromServer) / 2;\n    const threshold = 5;\n\n    if (infoEl) {\n        let text = 'Average request delay: ' + Math.round(avgToServer) + ' ms (browser \\u2192 server), '\n            + Math.round(avgFromServer) + ' ms (server \\u2192 browser).';\n        if (Math.abs(estimatedOffset) > threshold) {\n            clockOffset = estimatedOffset;\n            const sign = clockOffset >= 0 ? '+' : '';\n            text += ' Clocks appear to differ by ~' + sign + Math.round(clockOffset)\n                + ' ms. Latency values will be adjusted.';\n        } else {\n            clockOffset = null;\n            text += ' Browser and server clocks appear to be synchronised.';\n        }\n        infoEl.textContent = text;\n    }\n\n    // Show the recalibrate link.\n    const link = getRoot().querySelector(SELECTORS.action('recalibrate'));\n    if (link) {\n        link.classList.remove('d-none');\n    }\n\n    // Refresh adjusted column for any already-displayed results.\n    updateAdjustedDisplay();\n};\n\n/**\n * Send test events via AJAX web service\n *\n * @param {number} count\n * @param {boolean} useadhoc\n * @param {string} burstid\n * @param {number} delay Delay between events in milliseconds\n * @return {Promise}\n */\nconst sendTestEvents = (count, useadhoc, burstid, delay) => Ajax.call([{\n    methodname: 'tool_realtime_send_test_events',\n    args: {count, useadhoc, burstid, delay}\n}])[0];\n\n/**\n * Handle receive-single button click\n */\nconst handleReceiveSingle = async() => {\n    const burstid = generateBurstId();\n    resetReceiveStats(burstid);\n    updateStat('receive-status', 'Sending...');\n    showRegion('receive-results');\n    try {\n        await sendTestEvents(1, false, burstid, 0);\n    } catch (err) {\n        addReceiveError('Failed to send test event: ' + extractErrorMessage(err));\n        updateStat('receive-status', 'Error');\n        updateReceiveDisplay();\n    }\n};\n\n/**\n * Handle receive-burst button click\n */\nconst handleReceiveBurst = async() => {\n    const count = getFieldValue('receive-burst-count');\n    const delay = getFieldValue('receive-burst-delay', 0);\n    const burstid = generateBurstId();\n    resetReceiveStats(burstid);\n    receiveStats.expected = count;\n    updateStat('receive-status', 'Queued, waiting for cron...');\n    updateStat('receive-count', '0 / ' + count);\n    updateStat('receive-avg', '—');\n    updateStat('receive-minmax', '—');\n    updateStat('receive-avg-adjusted', '');\n    updateStat('receive-minmax-adjusted', '');\n    updateStat('receive-errors', '0');\n    hideRegion('receive-error-details');\n    showRegion('receive-results');\n    showResetButton('receive');\n    try {\n        await sendTestEvents(count, true, burstid, delay);\n        resetReceiveTimeout();\n    } catch (err) {\n        addReceiveError('Failed to queue burst task: ' + extractErrorMessage(err));\n        updateStat('receive-status', 'Error');\n        updateReceiveDisplay();\n    }\n};\n\n/**\n * Validate a push test response from the server\n *\n * Checks that the response contains receivedtime and that the echoed payload\n * matches what was originally sent.\n *\n * @param {Object} response The response from sendToServer\n * @param {Object} sentPayload The payload we originally sent\n * @return {string|null} Error message, or null if valid\n */\nconst validatePushResponse = (response, sentPayload) => {\n    if (!response) {\n        return 'Empty response from server';\n    }\n    if (typeof response.receivedtime === 'undefined') {\n        return 'Missing receivedtime in response (got: ' + JSON.stringify(response) + ')';\n    }\n    if (typeof response.receivedtime !== 'number' || response.receivedtime <= 0) {\n        return 'Invalid receivedtime: ' + response.receivedtime;\n    }\n    if (!response.echo) {\n        return 'Server did not echo back the payload';\n    }\n    // Verify the echoed senttime matches what we sent.\n    if (Number(response.echo.senttime) !== sentPayload.senttime) {\n        return 'Echoed senttime (' + response.echo.senttime + ') does not match sent value (' + sentPayload.senttime + ')';\n    }\n    return null;\n};\n\n/**\n * Handle push-burst button click\n */\nconst handlePushBurst = async() => {\n    const count = getFieldValue('push-burst-count');\n    const delay = getFieldValue('push-burst-delay', 0);\n    resetPushStats();\n    pushStats.expected = count;\n    updateStat('push-status', 'Sending...');\n    updateStat('push-count', '0 / ' + count);\n    updateStat('push-avg', '—');\n    updateStat('push-minmax', '—');\n    updateStat('push-errors', '0');\n    hideRegion('push-error-details');\n    showRegion('push-results');\n    showResetButton('push');\n\n    for (let i = 0; i < count; i++) {\n        if (i > 0 && delay > 0) {\n            await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n        const startTime = Date.now();\n        const payload = {senttime: startTime, seq: i, total: count};\n        try {\n            const response = await sendToServer('tool_realtime', payload, true);\n            const rtt = Date.now() - startTime;\n            const validationError = validatePushResponse(response, payload);\n\n            if (validationError) {\n                pushStats.errors++;\n                pushStats.errorMessages.push('Event ' + i + ': ' + validationError);\n            } else {\n                pushStats.count++;\n                pushStats.totalRtt += rtt;\n                pushStats.min = Math.min(pushStats.min, rtt);\n                pushStats.max = Math.max(pushStats.max, rtt);\n            }\n        } catch (err) {\n            pushStats.errors++;\n            pushStats.errorMessages.push('Event ' + i + ': ' + extractErrorMessage(err));\n        }\n        updatePushDisplay();\n    }\n    updateStat('push-status', pushStats.errors > 0 ? 'Complete (with errors)' : 'Complete');\n};\n\n/**\n * Handle receive-reset button click\n */\nconst handleReceiveReset = () => {\n    resetReceiveStats();\n    hideRegion('receive-results');\n    hideRegion('receive-error-details');\n    const el = getRoot().querySelector(SELECTORS.action('receive-reset'));\n    if (el) {\n        el.classList.add('d-none');\n    }\n};\n\n/**\n * Handle push-reset button click\n */\nconst handlePushReset = () => {\n    resetPushStats();\n    hideRegion('push-results');\n    hideRegion('push-error-details');\n    const el = getRoot().querySelector(SELECTORS.action('push-reset'));\n    if (el) {\n        el.classList.add('d-none');\n    }\n};\n\n/**\n * Initialise the test settings page\n */\nexport const init = () => {\n    // Subscribe to realtime events for the receive test.\n    PubSub.subscribe(RealTimeEvents.EVENT, onEventReceived);\n    PubSub.subscribe(RealTimeEvents.CONNECTION_LOST, () => {\n        addReceiveError('Connection lost');\n        updateStat('receive-status', 'Connection lost');\n        updateReceiveDisplay();\n    });\n\n    // Bind button click handlers.\n    const root = getRoot();\n    if (!root) {\n        return;\n    }\n\n    const actions = {\n        'receive-single': handleReceiveSingle,\n        'receive-burst': handleReceiveBurst,\n        'receive-reset': handleReceiveReset,\n        'push-burst': handlePushBurst,\n        'push-reset': handlePushReset,\n        'recalibrate': calibrateClockOffset,\n    };\n\n    root.addEventListener('click', (e) => {\n        const button = e.target.closest('[data-action]');\n        if (!button) {\n            return;\n        }\n        const action = button.dataset.action;\n        if (actions[action]) {\n            e.preventDefault();\n            actions[action]();\n        }\n    });\n\n    // Run clock offset calibration.\n    setTimeout(calibrateClockOffset, 1000);\n};\n"],"names":["SELECTORS","name","receiveStats","pushStats","receiveTimeoutId","clockOffset","generateBurstId","Date","now","toString","Math","random","slice","resetReceiveStats","burstid","clearReceiveTimeout","count","expected","totalLatency","min","Infinity","max","latencies","errors","errorMessages","seqReceived","Set","resetPushStats","totalRtt","getRoot","document","querySelector","updateStat","value","el","textContent","showRegion","classList","remove","hideRegion","add","showResetButton","section","getFieldValue","defaultValue","val","parseInt","isNaN","formatMs","ms","round","extractErrorMessage","err","message","error","debuginfo","String","addReceiveError","push","clearTimeout","resetReceiveTimeout","setTimeout","missing","updateReceiveDisplay","RECEIVE_TIMEOUT_SEC","updateAdjustedDisplay","total","raw","adjusted","avg","length","countText","join","updatePushDisplay","onEventReceived","data","component","area","payload","senttime","seq","JSON","stringify","has","latency","calibrateClockOffset","async","infoEl","recalibrateLink","timeUrl","Config","wwwroot","toServerSamples","fromServerSamples","i","t1","response","fetch","t4","text","t2","parseFloat","window","console","warn","avgToServer","reduce","a","b","avgFromServer","estimatedOffset","abs","link","sendTestEvents","useadhoc","delay","Ajax","call","methodname","args","handleReceiveSingle","handleReceiveBurst","validatePushResponse","sentPayload","receivedtime","echo","Number","handlePushBurst","Promise","resolve","startTime","rtt","validationError","handleReceiveReset","handlePushReset","PubSub","subscribe","RealTimeEvents","EVENT","CONNECTION_LOST","root","actions","addEventListener","e","button","target","closest","action","dataset","preventDefault"],"mappings":"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"}