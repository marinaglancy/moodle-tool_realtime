{"version":3,"file":"test_settings.min.js","sources":["../src/test_settings.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * JavaScript for the test settings page\n *\n * @module     tool_realtime/test_settings\n * @copyright  Marina Glancy\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Ajax from 'core/ajax';\nimport * as PubSub from 'core/pubsub';\nimport RealTimeEvents from 'tool_realtime/events';\nimport {sendToServer} from 'tool_realtime/api';\n\n/** @type {number} Seconds without events before showing timeout warning */\nconst RECEIVE_TIMEOUT_SEC = 90;\n\nconst SELECTORS = {\n    root: '#tool-realtime-test-settings',\n    stat: (name) => `[data-stat=\"${name}\"]`,\n    action: (name) => `[data-action=\"${name}\"]`,\n    field: (name) => `[data-field=\"${name}\"]`,\n    region: (name) => `[data-region=\"${name}\"]`,\n};\n\n/** @type {Object} Stats for receive test */\nlet receiveStats = null;\n\n/** @type {Object} Stats for push test */\nlet pushStats = null;\n\n/** @type {number|null} Timer ID for receive timeout detection */\nlet receiveTimeoutId = null;\n\n/**\n * Generate a unique burst identifier\n *\n * @return {string}\n */\nconst generateBurstId = () => Date.now().toString(36) + Math.random().toString(36).slice(2, 8);\n\n/**\n * Reset receive stats\n *\n * @param {string} burstid\n */\nconst resetReceiveStats = (burstid = '') => {\n    clearReceiveTimeout();\n    receiveStats = {\n        count: 0,\n        expected: 0,\n        totalLatency: 0,\n        min: Infinity,\n        max: -Infinity,\n        errors: 0,\n        errorMessages: [],\n        seqReceived: new Set(),\n        burstid: burstid,\n    };\n};\n\n/**\n * Reset push stats\n */\nconst resetPushStats = () => {\n    pushStats = {\n        count: 0,\n        expected: 0,\n        totalRtt: 0,\n        min: Infinity,\n        max: -Infinity,\n        errors: 0,\n        errorMessages: [],\n    };\n};\n\n/**\n * Get the root element\n *\n * @return {HTMLElement}\n */\nconst getRoot = () => document.querySelector(SELECTORS.root);\n\n/**\n * Update a stat display element\n *\n * @param {string} name\n * @param {string} value\n */\nconst updateStat = (name, value) => {\n    const el = getRoot().querySelector(SELECTORS.stat(name));\n    if (el) {\n        el.textContent = value;\n    }\n};\n\n/**\n * Show a results region\n *\n * @param {string} name\n */\nconst showRegion = (name) => {\n    const el = getRoot().querySelector(SELECTORS.region(name));\n    if (el) {\n        el.classList.remove('d-none');\n    }\n};\n\n/**\n * Hide a results region\n *\n * @param {string} name\n */\nconst hideRegion = (name) => {\n    const el = getRoot().querySelector(SELECTORS.region(name));\n    if (el) {\n        el.classList.add('d-none');\n    }\n};\n\n/**\n * Show the reset button for a section\n *\n * @param {string} section\n */\nconst showResetButton = (section) => {\n    const el = getRoot().querySelector(SELECTORS.action(section + '-reset'));\n    if (el) {\n        el.classList.remove('d-none');\n    }\n};\n\n/**\n * Get field value\n *\n * @param {string} name\n * @param {number} defaultValue\n * @return {number}\n */\nconst getFieldValue = (name, defaultValue = 1) => {\n    const el = getRoot().querySelector(SELECTORS.field(name));\n    if (!el) {\n        return defaultValue;\n    }\n    const val = parseInt(el.value, 10);\n    return isNaN(val) ? defaultValue : val;\n};\n\n/**\n * Format milliseconds for display\n *\n * @param {number} ms\n * @return {string}\n */\nconst formatMs = (ms) => Math.round(ms) + ' ms';\n\n/**\n * Extract a readable error message from various error object formats\n *\n * Moodle Ajax errors can be plain strings, Error objects, or objects with\n * .message, .error, or .debuginfo properties.\n *\n * @param {*} err\n * @return {string}\n */\nconst extractErrorMessage = (err) => {\n    if (!err) {\n        return 'Unknown error';\n    }\n    if (typeof err === 'string') {\n        return err;\n    }\n    if (err.message) {\n        return err.message;\n    }\n    if (err.error) {\n        return err.error + (err.debuginfo ? ' (' + err.debuginfo + ')' : '');\n    }\n    return String(err);\n};\n\n/**\n * Add an error to receive stats and update the display\n *\n * @param {string} message\n */\nconst addReceiveError = (message) => {\n    if (!receiveStats) {\n        resetReceiveStats();\n    }\n    receiveStats.errors++;\n    receiveStats.errorMessages.push(message);\n};\n\n/**\n * Clear the receive timeout timer\n */\nconst clearReceiveTimeout = () => {\n    if (receiveTimeoutId !== null) {\n        clearTimeout(receiveTimeoutId);\n        receiveTimeoutId = null;\n    }\n};\n\n/**\n * Start or reset the receive timeout timer\n *\n * If no events arrive within RECEIVE_TIMEOUT_SEC seconds, records a timeout error.\n */\nconst resetReceiveTimeout = () => {\n    clearReceiveTimeout();\n    if (receiveStats && receiveStats.expected > 0 && receiveStats.count < receiveStats.expected) {\n        receiveTimeoutId = setTimeout(() => {\n            const missing = receiveStats.expected - receiveStats.count;\n            addReceiveError('Timeout: ' + missing + ' event(s) not received within ' + RECEIVE_TIMEOUT_SEC + 's');\n            updateStat('receive-status', 'Timeout (' + receiveStats.count + ' of ' + receiveStats.expected + ' received)');\n            updateReceiveDisplay();\n        }, RECEIVE_TIMEOUT_SEC * 1000);\n    }\n};\n\n/**\n * Update receive stats display\n */\nconst updateReceiveDisplay = () => {\n    showRegion('receive-results');\n    showResetButton('receive');\n\n    const countText = receiveStats.expected > 0\n        ? receiveStats.count + ' / ' + receiveStats.expected\n        : String(receiveStats.count);\n    updateStat('receive-count', countText);\n    updateStat('receive-errors', String(receiveStats.errors));\n\n    if (receiveStats.count > 0) {\n        const avg = receiveStats.totalLatency / receiveStats.count;\n        updateStat('receive-avg', formatMs(avg));\n        updateStat('receive-minmax', formatMs(receiveStats.min) + ' / ' + formatMs(receiveStats.max));\n    }\n\n    if (receiveStats.errors > 0) {\n        showRegion('receive-error-details');\n        const el = getRoot().querySelector(SELECTORS.region('receive-error-messages'));\n        if (el) {\n            el.textContent = receiveStats.errorMessages.join('\\n');\n        }\n    }\n\n    if (receiveStats.expected > 0 && receiveStats.count >= receiveStats.expected) {\n        clearReceiveTimeout();\n        updateStat('receive-status', receiveStats.errors > 0 ? 'Complete (with errors)' : 'Complete');\n    }\n};\n\n/**\n * Update push stats display\n */\nconst updatePushDisplay = () => {\n    showRegion('push-results');\n    showResetButton('push');\n\n    const countText = pushStats.expected > 0\n        ? pushStats.count + ' / ' + pushStats.expected\n        : String(pushStats.count);\n    updateStat('push-count', countText);\n    updateStat('push-errors', String(pushStats.errors));\n\n    if (pushStats.count > 0) {\n        const avg = pushStats.totalRtt / pushStats.count;\n        updateStat('push-avg', formatMs(avg));\n        updateStat('push-minmax', formatMs(pushStats.min) + ' / ' + formatMs(pushStats.max));\n    }\n\n    if (pushStats.errors > 0) {\n        showRegion('push-error-details');\n        const el = getRoot().querySelector(SELECTORS.region('push-error-messages'));\n        if (el) {\n            el.textContent = pushStats.errorMessages.join('\\n');\n        }\n    }\n\n    if (pushStats.expected > 0 && (pushStats.count + pushStats.errors) >= pushStats.expected) {\n        updateStat('push-status', pushStats.errors > 0 ? 'Complete (with errors)' : 'Complete');\n    }\n};\n\n/**\n * Handle incoming realtime event for the receive test\n *\n * @param {Object} data\n */\nconst onEventReceived = (data) => {\n    if (data.component !== 'tool_realtime' || data.area !== 'test') {\n        return;\n    }\n    if (!receiveStats) {\n        return;\n    }\n\n    const payload = data.payload || {};\n\n    // Ignore events from a different burst.\n    if (receiveStats.burstid && payload.burstid !== receiveStats.burstid) {\n        return;\n    }\n\n    const now = Date.now();\n    const senttime = parseInt(payload.senttime, 10);\n    const seq = parseInt(payload.seq, 10);\n    const total = parseInt(payload.total, 10);\n\n    if (total > 0) {\n        receiveStats.expected = total;\n    }\n\n    // Validate payload has required senttime.\n    if (!senttime || isNaN(senttime) || senttime <= 0) {\n        addReceiveError('Event received with missing or invalid senttime: ' + JSON.stringify(payload));\n        updateReceiveDisplay();\n        return;\n    }\n\n    // Check for duplicate sequence numbers (only meaningful during burst tests).\n    if (receiveStats.expected > 1 && !isNaN(seq)) {\n        if (receiveStats.seqReceived.has(seq)) {\n            addReceiveError('Duplicate event received for seq=' + seq);\n        }\n        receiveStats.seqReceived.add(seq);\n    }\n\n    const latency = now - senttime;\n    receiveStats.count++;\n    receiveStats.totalLatency += latency;\n    receiveStats.min = Math.min(receiveStats.min, latency);\n    receiveStats.max = Math.max(receiveStats.max, latency);\n\n    updateStat('receive-status', 'Receiving...');\n    resetReceiveTimeout();\n    updateReceiveDisplay();\n};\n\n/**\n * Send test events via AJAX web service\n *\n * @param {number} count\n * @param {boolean} useadhoc\n * @param {string} burstid\n * @param {number} delay Delay between events in milliseconds\n * @return {Promise}\n */\nconst sendTestEvents = (count, useadhoc, burstid, delay) => Ajax.call([{\n    methodname: 'tool_realtime_send_test_events',\n    args: {count, useadhoc, burstid, delay}\n}])[0];\n\n/**\n * Handle receive-single button click\n */\nconst handleReceiveSingle = async() => {\n    const burstid = generateBurstId();\n    resetReceiveStats(burstid);\n    updateStat('receive-status', 'Sending...');\n    showRegion('receive-results');\n    try {\n        await sendTestEvents(1, false, burstid, 0);\n    } catch (err) {\n        addReceiveError('Failed to send test event: ' + extractErrorMessage(err));\n        updateStat('receive-status', 'Error');\n        updateReceiveDisplay();\n    }\n};\n\n/**\n * Handle receive-burst button click\n */\nconst handleReceiveBurst = async() => {\n    const count = getFieldValue('receive-burst-count');\n    const delay = getFieldValue('receive-burst-delay', 0);\n    const burstid = generateBurstId();\n    resetReceiveStats(burstid);\n    receiveStats.expected = count;\n    updateStat('receive-status', 'Queued, waiting for cron...');\n    updateStat('receive-count', '0 / ' + count);\n    updateStat('receive-avg', '—');\n    updateStat('receive-minmax', '—');\n    updateStat('receive-errors', '0');\n    hideRegion('receive-error-details');\n    showRegion('receive-results');\n    showResetButton('receive');\n    try {\n        await sendTestEvents(count, true, burstid, delay);\n        resetReceiveTimeout();\n    } catch (err) {\n        addReceiveError('Failed to queue burst task: ' + extractErrorMessage(err));\n        updateStat('receive-status', 'Error');\n        updateReceiveDisplay();\n    }\n};\n\n/**\n * Validate a push test response from the server\n *\n * Checks that the response contains receivedtime and that the echoed payload\n * matches what was originally sent.\n *\n * @param {Object} response The response from sendToServer\n * @param {Object} sentPayload The payload we originally sent\n * @return {string|null} Error message, or null if valid\n */\nconst validatePushResponse = (response, sentPayload) => {\n    if (!response) {\n        return 'Empty response from server';\n    }\n    if (typeof response.receivedtime === 'undefined') {\n        return 'Missing receivedtime in response (got: ' + JSON.stringify(response) + ')';\n    }\n    if (typeof response.receivedtime !== 'number' || response.receivedtime <= 0) {\n        return 'Invalid receivedtime: ' + response.receivedtime;\n    }\n    if (!response.echo) {\n        return 'Server did not echo back the payload';\n    }\n    // Verify the echoed senttime matches what we sent.\n    if (Number(response.echo.senttime) !== sentPayload.senttime) {\n        return 'Echoed senttime (' + response.echo.senttime + ') does not match sent value (' + sentPayload.senttime + ')';\n    }\n    return null;\n};\n\n/**\n * Handle push-burst button click\n */\nconst handlePushBurst = async() => {\n    const count = getFieldValue('push-burst-count');\n    const delay = getFieldValue('push-burst-delay', 0);\n    resetPushStats();\n    pushStats.expected = count;\n    updateStat('push-status', 'Sending...');\n    updateStat('push-count', '0 / ' + count);\n    updateStat('push-avg', '—');\n    updateStat('push-minmax', '—');\n    updateStat('push-errors', '0');\n    hideRegion('push-error-details');\n    showRegion('push-results');\n    showResetButton('push');\n\n    for (let i = 0; i < count; i++) {\n        if (i > 0 && delay > 0) {\n            await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n        const startTime = Date.now();\n        const payload = {senttime: startTime, seq: i, total: count};\n        try {\n            const response = await sendToServer('tool_realtime', payload, true);\n            const rtt = Date.now() - startTime;\n            const validationError = validatePushResponse(response, payload);\n\n            if (validationError) {\n                pushStats.errors++;\n                pushStats.errorMessages.push('Event ' + i + ': ' + validationError);\n            } else {\n                pushStats.count++;\n                pushStats.totalRtt += rtt;\n                pushStats.min = Math.min(pushStats.min, rtt);\n                pushStats.max = Math.max(pushStats.max, rtt);\n            }\n        } catch (err) {\n            pushStats.errors++;\n            pushStats.errorMessages.push('Event ' + i + ': ' + extractErrorMessage(err));\n        }\n        updatePushDisplay();\n    }\n    updateStat('push-status', pushStats.errors > 0 ? 'Complete (with errors)' : 'Complete');\n};\n\n/**\n * Handle receive-reset button click\n */\nconst handleReceiveReset = () => {\n    resetReceiveStats();\n    hideRegion('receive-results');\n    hideRegion('receive-error-details');\n    const el = getRoot().querySelector(SELECTORS.action('receive-reset'));\n    if (el) {\n        el.classList.add('d-none');\n    }\n};\n\n/**\n * Handle push-reset button click\n */\nconst handlePushReset = () => {\n    resetPushStats();\n    hideRegion('push-results');\n    hideRegion('push-error-details');\n    const el = getRoot().querySelector(SELECTORS.action('push-reset'));\n    if (el) {\n        el.classList.add('d-none');\n    }\n};\n\n/**\n * Initialise the test settings page\n */\nexport const init = () => {\n    // Subscribe to realtime events for the receive test.\n    PubSub.subscribe(RealTimeEvents.EVENT, onEventReceived);\n    PubSub.subscribe(RealTimeEvents.CONNECTION_LOST, () => {\n        if (receiveStats) {\n            addReceiveError('Connection lost');\n            updateStat('receive-status', 'Connection lost');\n            updateReceiveDisplay();\n        }\n    });\n\n    // Bind button click handlers.\n    const root = getRoot();\n    if (!root) {\n        return;\n    }\n\n    const actions = {\n        'receive-single': handleReceiveSingle,\n        'receive-burst': handleReceiveBurst,\n        'receive-reset': handleReceiveReset,\n        'push-burst': handlePushBurst,\n        'push-reset': handlePushReset,\n    };\n\n    root.addEventListener('click', (e) => {\n        const button = e.target.closest('[data-action]');\n        if (!button) {\n            return;\n        }\n        const action = button.dataset.action;\n        if (actions[action]) {\n            actions[action]();\n        }\n    });\n\n};\n"],"names":["SELECTORS","name","receiveStats","pushStats","receiveTimeoutId","generateBurstId","Date","now","toString","Math","random","slice","resetReceiveStats","burstid","clearReceiveTimeout","count","expected","totalLatency","min","Infinity","max","errors","errorMessages","seqReceived","Set","resetPushStats","totalRtt","getRoot","document","querySelector","updateStat","value","el","textContent","showRegion","classList","remove","hideRegion","add","showResetButton","section","getFieldValue","defaultValue","val","parseInt","isNaN","formatMs","ms","round","extractErrorMessage","err","message","error","debuginfo","String","addReceiveError","push","clearTimeout","resetReceiveTimeout","setTimeout","missing","updateReceiveDisplay","RECEIVE_TIMEOUT_SEC","countText","avg","join","updatePushDisplay","onEventReceived","data","component","area","payload","senttime","seq","total","JSON","stringify","has","latency","sendTestEvents","useadhoc","delay","Ajax","call","methodname","args","handleReceiveSingle","async","handleReceiveBurst","validatePushResponse","response","sentPayload","receivedtime","echo","Number","handlePushBurst","i","Promise","resolve","startTime","rtt","validationError","handleReceiveReset","handlePushReset","PubSub","subscribe","RealTimeEvents","EVENT","CONNECTION_LOST","root","actions","addEventListener","e","button","target","closest","action","dataset"],"mappings":"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"}