{"version":3,"file":"test_settings.min.js","sources":["../src/test_settings.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * JavaScript for the test settings page\n *\n * @module     tool_realtime/test_settings\n * @copyright  Marina Glancy\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Ajax from 'core/ajax';\nimport * as PubSub from 'core/pubsub';\nimport RealTimeEvents from 'tool_realtime/events';\nimport {sendToServer} from 'tool_realtime/api';\n\n/** @type {number} Seconds without events before showing timeout warning */\nconst RECEIVE_TIMEOUT_SEC = 90;\n\nconst SELECTORS = {\n    root: '#tool-realtime-test-settings',\n    stat: (name) => `[data-stat=\"${name}\"]`,\n    action: (name) => `[data-action=\"${name}\"]`,\n    field: (name) => `[data-field=\"${name}\"]`,\n    region: (name) => `[data-region=\"${name}\"]`,\n};\n\n/** @type {Object} Stats for receive test */\nlet receiveStats = null;\n\n/** @type {Object} Stats for push test */\nlet pushStats = null;\n\n/** @type {number|null} Timer ID for receive timeout detection */\nlet receiveTimeoutId = null;\n\n/** @type {number|null} Estimated clock offset (server - browser) in ms, null if not yet calibrated */\nlet clockOffset = null;\n\n/** @type {number} Number of calibration round-trips */\nconst CALIBRATION_SAMPLES = 5;\n\n/**\n * Generate a unique burst identifier\n *\n * @return {string}\n */\nconst generateBurstId = () => Date.now().toString(36) + Math.random().toString(36).slice(2, 8);\n\n/**\n * Reset receive stats\n *\n * @param {string} burstid\n */\nconst resetReceiveStats = (burstid = '') => {\n    clearReceiveTimeout();\n    receiveStats = {\n        count: 0,\n        expected: 0,\n        totalLatency: 0,\n        min: Infinity,\n        max: -Infinity,\n        adjustedTotalLatency: 0,\n        adjustedMin: Infinity,\n        adjustedMax: -Infinity,\n        errors: 0,\n        errorMessages: [],\n        seqReceived: new Set(),\n        burstid: burstid,\n    };\n};\n\n/**\n * Reset push stats\n */\nconst resetPushStats = () => {\n    pushStats = {\n        count: 0,\n        expected: 0,\n        totalRtt: 0,\n        min: Infinity,\n        max: -Infinity,\n        errors: 0,\n        errorMessages: [],\n    };\n};\n\n/**\n * Get the root element\n *\n * @return {HTMLElement}\n */\nconst getRoot = () => document.querySelector(SELECTORS.root);\n\n/**\n * Update a stat display element\n *\n * @param {string} name\n * @param {string} value\n */\nconst updateStat = (name, value) => {\n    const el = getRoot().querySelector(SELECTORS.stat(name));\n    if (el) {\n        el.textContent = value;\n    }\n};\n\n/**\n * Show a results region\n *\n * @param {string} name\n */\nconst showRegion = (name) => {\n    const el = getRoot().querySelector(SELECTORS.region(name));\n    if (el) {\n        el.classList.remove('d-none');\n    }\n};\n\n/**\n * Hide a results region\n *\n * @param {string} name\n */\nconst hideRegion = (name) => {\n    const el = getRoot().querySelector(SELECTORS.region(name));\n    if (el) {\n        el.classList.add('d-none');\n    }\n};\n\n/**\n * Show the reset button for a section\n *\n * @param {string} section\n */\nconst showResetButton = (section) => {\n    const el = getRoot().querySelector(SELECTORS.action(section + '-reset'));\n    if (el) {\n        el.classList.remove('d-none');\n    }\n};\n\n/**\n * Get field value\n *\n * @param {string} name\n * @param {number} defaultValue\n * @return {number}\n */\nconst getFieldValue = (name, defaultValue = 1) => {\n    const el = getRoot().querySelector(SELECTORS.field(name));\n    if (!el) {\n        return defaultValue;\n    }\n    const val = parseInt(el.value, 10);\n    return isNaN(val) ? defaultValue : val;\n};\n\n/**\n * Format milliseconds for display\n *\n * @param {number} ms\n * @return {string}\n */\nconst formatMs = (ms) => Math.round(ms) + ' ms';\n\n/**\n * Extract a readable error message from various error object formats\n *\n * Moodle Ajax errors can be plain strings, Error objects, or objects with\n * .message, .error, or .debuginfo properties.\n *\n * @param {*} err\n * @return {string}\n */\nconst extractErrorMessage = (err) => {\n    if (!err) {\n        return 'Unknown error';\n    }\n    if (typeof err === 'string') {\n        return err;\n    }\n    if (err.message) {\n        return err.message;\n    }\n    if (err.error) {\n        return err.error + (err.debuginfo ? ' (' + err.debuginfo + ')' : '');\n    }\n    return String(err);\n};\n\n/**\n * Add an error to receive stats and update the display\n *\n * @param {string} message\n */\nconst addReceiveError = (message) => {\n    if (!receiveStats) {\n        resetReceiveStats();\n    }\n    receiveStats.errors++;\n    receiveStats.errorMessages.push(message);\n};\n\n/**\n * Clear the receive timeout timer\n */\nconst clearReceiveTimeout = () => {\n    if (receiveTimeoutId !== null) {\n        clearTimeout(receiveTimeoutId);\n        receiveTimeoutId = null;\n    }\n};\n\n/**\n * Start or reset the receive timeout timer\n *\n * If no events arrive within RECEIVE_TIMEOUT_SEC seconds, records a timeout error.\n */\nconst resetReceiveTimeout = () => {\n    clearReceiveTimeout();\n    if (receiveStats && receiveStats.expected > 0 && receiveStats.count < receiveStats.expected) {\n        receiveTimeoutId = setTimeout(() => {\n            const missing = receiveStats.expected - receiveStats.count;\n            addReceiveError('Timeout: ' + missing + ' event(s) not received within ' + RECEIVE_TIMEOUT_SEC + 's');\n            updateStat('receive-status', 'Timeout (' + receiveStats.count + ' of ' + receiveStats.expected + ' received)');\n            updateReceiveDisplay();\n        }, RECEIVE_TIMEOUT_SEC * 1000);\n    }\n};\n\n/**\n * Update receive stats display\n */\nconst updateReceiveDisplay = () => {\n    showRegion('receive-results');\n    showResetButton('receive');\n\n    const countText = receiveStats.expected > 0\n        ? receiveStats.count + ' / ' + receiveStats.expected\n        : String(receiveStats.count);\n    updateStat('receive-count', countText);\n    updateStat('receive-errors', String(receiveStats.errors));\n\n    if (receiveStats.count > 0) {\n        const avg = receiveStats.totalLatency / receiveStats.count;\n        updateStat('receive-avg', formatMs(avg));\n        updateStat('receive-minmax', formatMs(receiveStats.min) + ' / ' + formatMs(receiveStats.max));\n\n        if (clockOffset !== null) {\n            const adjustedAvg = receiveStats.adjustedTotalLatency / receiveStats.count;\n            updateStat('receive-avg-adjusted', formatMs(adjustedAvg) + ' (adjusted)');\n            updateStat('receive-minmax-adjusted',\n                formatMs(receiveStats.adjustedMin) + ' / ' + formatMs(receiveStats.adjustedMax) + ' (adjusted)');\n        } else {\n            updateStat('receive-avg-adjusted', '');\n            updateStat('receive-minmax-adjusted', '');\n        }\n    }\n\n    if (receiveStats.errors > 0) {\n        showRegion('receive-error-details');\n        const el = getRoot().querySelector(SELECTORS.region('receive-error-messages'));\n        if (el) {\n            el.textContent = receiveStats.errorMessages.join('\\n');\n        }\n    }\n\n    if (receiveStats.expected > 0 && receiveStats.count >= receiveStats.expected) {\n        clearReceiveTimeout();\n        updateStat('receive-status', receiveStats.errors > 0 ? 'Complete (with errors)' : 'Complete');\n    }\n};\n\n/**\n * Update push stats display\n */\nconst updatePushDisplay = () => {\n    showRegion('push-results');\n    showResetButton('push');\n\n    const countText = pushStats.expected > 0\n        ? pushStats.count + ' / ' + pushStats.expected\n        : String(pushStats.count);\n    updateStat('push-count', countText);\n    updateStat('push-errors', String(pushStats.errors));\n\n    if (pushStats.count > 0) {\n        const avg = pushStats.totalRtt / pushStats.count;\n        updateStat('push-avg', formatMs(avg));\n        updateStat('push-minmax', formatMs(pushStats.min) + ' / ' + formatMs(pushStats.max));\n    }\n\n    if (pushStats.errors > 0) {\n        showRegion('push-error-details');\n        const el = getRoot().querySelector(SELECTORS.region('push-error-messages'));\n        if (el) {\n            el.textContent = pushStats.errorMessages.join('\\n');\n        }\n    }\n\n    if (pushStats.expected > 0 && (pushStats.count + pushStats.errors) >= pushStats.expected) {\n        updateStat('push-status', pushStats.errors > 0 ? 'Complete (with errors)' : 'Complete');\n    }\n};\n\n/**\n * Handle incoming realtime event for the receive test\n *\n * @param {Object} data\n */\nconst onEventReceived = (data) => {\n    if (data.component !== 'tool_realtime' || data.area !== 'test') {\n        return;\n    }\n    if (!receiveStats) {\n        return;\n    }\n\n    const payload = data.payload || {};\n\n    // Ignore events from a different burst.\n    if (receiveStats.burstid && payload.burstid !== receiveStats.burstid) {\n        return;\n    }\n\n    const now = Date.now();\n    const senttime = parseInt(payload.senttime, 10);\n    const seq = parseInt(payload.seq, 10);\n    const total = parseInt(payload.total, 10);\n\n    if (total > 0) {\n        receiveStats.expected = total;\n    }\n\n    // Validate payload has required senttime.\n    if (!senttime || isNaN(senttime) || senttime <= 0) {\n        addReceiveError('Event received with missing or invalid senttime: ' + JSON.stringify(payload));\n        updateReceiveDisplay();\n        return;\n    }\n\n    // Check for duplicate sequence numbers (only meaningful during burst tests).\n    if (receiveStats.expected > 1 && !isNaN(seq)) {\n        if (receiveStats.seqReceived.has(seq)) {\n            addReceiveError('Duplicate event received for seq=' + seq);\n        }\n        receiveStats.seqReceived.add(seq);\n    }\n\n    const latency = now - senttime;\n    const adjustedLatency = latency + (clockOffset || 0);\n    receiveStats.count++;\n    receiveStats.totalLatency += latency;\n    receiveStats.min = Math.min(receiveStats.min, latency);\n    receiveStats.max = Math.max(receiveStats.max, latency);\n    receiveStats.adjustedTotalLatency += adjustedLatency;\n    receiveStats.adjustedMin = Math.min(receiveStats.adjustedMin, adjustedLatency);\n    receiveStats.adjustedMax = Math.max(receiveStats.adjustedMax, adjustedLatency);\n\n    updateStat('receive-status', 'Receiving...');\n    resetReceiveTimeout();\n    updateReceiveDisplay();\n};\n\n/**\n * Calibrate the clock offset between browser and server\n *\n * Sends CALIBRATION_SAMPLES AJAX requests and measures apparent one-way delays in each direction.\n * The server returns its midpoint timestamp, so processing time is split evenly.\n * offset = (avgToServer - avgFromServer) / 2 estimates the server-browser clock difference.\n *\n * @return {Promise<void>}\n */\nconst calibrateClockOffset = async() => {\n    const infoEl = getRoot().querySelector(SELECTORS.region('calibration-info'));\n    if (infoEl) {\n        infoEl.textContent = 'Calibrating...';\n    }\n    const recalibrateLink = getRoot().querySelector(SELECTORS.action('recalibrate'));\n    if (recalibrateLink) {\n        recalibrateLink.classList.add('d-none');\n    }\n\n    const toServerSamples = [];\n    const fromServerSamples = [];\n\n    for (let i = 0; i < CALIBRATION_SAMPLES; i++) {\n        try {\n            const t1 = Date.now();\n            const burstid = generateBurstId();\n            const response = await sendTestEvents(1, false, burstid, 0);\n            const t4 = Date.now();\n\n            const t2 = response?.servertime;\n            if (t2 > 0) {\n                toServerSamples.push(t2 - t1);\n                fromServerSamples.push(t4 - t2);\n            }\n        } catch (err) {\n            window.console.warn('Clock calibration sample failed:', err);\n        }\n    }\n\n    if (toServerSamples.length === 0) {\n        if (infoEl) {\n            infoEl.textContent = 'Clock calibration failed.';\n        }\n        return;\n    }\n\n    const avgToServer = toServerSamples.reduce((a, b) => a + b) / toServerSamples.length;\n    const avgFromServer = fromServerSamples.reduce((a, b) => a + b) / fromServerSamples.length;\n    clockOffset = (avgToServer - avgFromServer) / 2;\n\n    if (infoEl) {\n        let text = 'Average request delay: ' + Math.round(avgToServer) + ' ms (browser \\u2192 server), '\n            + Math.round(avgFromServer) + ' ms (server \\u2192 browser).';\n        const threshold = 5;\n        if (Math.abs(avgToServer - avgFromServer) > threshold) {\n            const sign = clockOffset >= 0 ? '+' : '';\n            text += ' Clocks appear to differ by ~' + sign + Math.round(clockOffset)\n                + ' ms. Latency values will be adjusted.';\n        } else {\n            text += ' Browser and server clocks appear to be synchronised.';\n        }\n        infoEl.textContent = text;\n    }\n\n    // Show the recalibrate link.\n    const link = getRoot().querySelector(SELECTORS.action('recalibrate'));\n    if (link) {\n        link.classList.remove('d-none');\n    }\n};\n\n/**\n * Send test events via AJAX web service\n *\n * @param {number} count\n * @param {boolean} useadhoc\n * @param {string} burstid\n * @param {number} delay Delay between events in milliseconds\n * @return {Promise}\n */\nconst sendTestEvents = (count, useadhoc, burstid, delay) => Ajax.call([{\n    methodname: 'tool_realtime_send_test_events',\n    args: {count, useadhoc, burstid, delay}\n}])[0];\n\n/**\n * Handle receive-single button click\n */\nconst handleReceiveSingle = async() => {\n    const burstid = generateBurstId();\n    resetReceiveStats(burstid);\n    updateStat('receive-status', 'Sending...');\n    showRegion('receive-results');\n    try {\n        await sendTestEvents(1, false, burstid, 0);\n    } catch (err) {\n        addReceiveError('Failed to send test event: ' + extractErrorMessage(err));\n        updateStat('receive-status', 'Error');\n        updateReceiveDisplay();\n    }\n};\n\n/**\n * Handle receive-burst button click\n */\nconst handleReceiveBurst = async() => {\n    const count = getFieldValue('receive-burst-count');\n    const delay = getFieldValue('receive-burst-delay', 0);\n    const burstid = generateBurstId();\n    resetReceiveStats(burstid);\n    receiveStats.expected = count;\n    updateStat('receive-status', 'Queued, waiting for cron...');\n    updateStat('receive-count', '0 / ' + count);\n    updateStat('receive-avg', '—');\n    updateStat('receive-minmax', '—');\n    updateStat('receive-avg-adjusted', '');\n    updateStat('receive-minmax-adjusted', '');\n    updateStat('receive-errors', '0');\n    hideRegion('receive-error-details');\n    showRegion('receive-results');\n    showResetButton('receive');\n    try {\n        await sendTestEvents(count, true, burstid, delay);\n        resetReceiveTimeout();\n    } catch (err) {\n        addReceiveError('Failed to queue burst task: ' + extractErrorMessage(err));\n        updateStat('receive-status', 'Error');\n        updateReceiveDisplay();\n    }\n};\n\n/**\n * Validate a push test response from the server\n *\n * Checks that the response contains receivedtime and that the echoed payload\n * matches what was originally sent.\n *\n * @param {Object} response The response from sendToServer\n * @param {Object} sentPayload The payload we originally sent\n * @return {string|null} Error message, or null if valid\n */\nconst validatePushResponse = (response, sentPayload) => {\n    if (!response) {\n        return 'Empty response from server';\n    }\n    if (typeof response.receivedtime === 'undefined') {\n        return 'Missing receivedtime in response (got: ' + JSON.stringify(response) + ')';\n    }\n    if (typeof response.receivedtime !== 'number' || response.receivedtime <= 0) {\n        return 'Invalid receivedtime: ' + response.receivedtime;\n    }\n    if (!response.echo) {\n        return 'Server did not echo back the payload';\n    }\n    // Verify the echoed senttime matches what we sent.\n    if (Number(response.echo.senttime) !== sentPayload.senttime) {\n        return 'Echoed senttime (' + response.echo.senttime + ') does not match sent value (' + sentPayload.senttime + ')';\n    }\n    return null;\n};\n\n/**\n * Handle push-burst button click\n */\nconst handlePushBurst = async() => {\n    const count = getFieldValue('push-burst-count');\n    const delay = getFieldValue('push-burst-delay', 0);\n    resetPushStats();\n    pushStats.expected = count;\n    updateStat('push-status', 'Sending...');\n    updateStat('push-count', '0 / ' + count);\n    updateStat('push-avg', '—');\n    updateStat('push-minmax', '—');\n    updateStat('push-errors', '0');\n    hideRegion('push-error-details');\n    showRegion('push-results');\n    showResetButton('push');\n\n    for (let i = 0; i < count; i++) {\n        if (i > 0 && delay > 0) {\n            await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n        const startTime = Date.now();\n        const payload = {senttime: startTime, seq: i, total: count};\n        try {\n            const response = await sendToServer('tool_realtime', payload, true);\n            const rtt = Date.now() - startTime;\n            const validationError = validatePushResponse(response, payload);\n\n            if (validationError) {\n                pushStats.errors++;\n                pushStats.errorMessages.push('Event ' + i + ': ' + validationError);\n            } else {\n                pushStats.count++;\n                pushStats.totalRtt += rtt;\n                pushStats.min = Math.min(pushStats.min, rtt);\n                pushStats.max = Math.max(pushStats.max, rtt);\n            }\n        } catch (err) {\n            pushStats.errors++;\n            pushStats.errorMessages.push('Event ' + i + ': ' + extractErrorMessage(err));\n        }\n        updatePushDisplay();\n    }\n    updateStat('push-status', pushStats.errors > 0 ? 'Complete (with errors)' : 'Complete');\n};\n\n/**\n * Handle receive-reset button click\n */\nconst handleReceiveReset = () => {\n    resetReceiveStats();\n    hideRegion('receive-results');\n    hideRegion('receive-error-details');\n    const el = getRoot().querySelector(SELECTORS.action('receive-reset'));\n    if (el) {\n        el.classList.add('d-none');\n    }\n};\n\n/**\n * Handle push-reset button click\n */\nconst handlePushReset = () => {\n    resetPushStats();\n    hideRegion('push-results');\n    hideRegion('push-error-details');\n    const el = getRoot().querySelector(SELECTORS.action('push-reset'));\n    if (el) {\n        el.classList.add('d-none');\n    }\n};\n\n/**\n * Initialise the test settings page\n */\nexport const init = () => {\n    // Subscribe to realtime events for the receive test.\n    PubSub.subscribe(RealTimeEvents.EVENT, onEventReceived);\n    PubSub.subscribe(RealTimeEvents.CONNECTION_LOST, () => {\n        addReceiveError('Connection lost');\n        updateStat('receive-status', 'Connection lost');\n        updateReceiveDisplay();\n    });\n\n    // Bind button click handlers.\n    const root = getRoot();\n    if (!root) {\n        return;\n    }\n\n    const actions = {\n        'receive-single': handleReceiveSingle,\n        'receive-burst': handleReceiveBurst,\n        'receive-reset': handleReceiveReset,\n        'push-burst': handlePushBurst,\n        'push-reset': handlePushReset,\n        'recalibrate': calibrateClockOffset,\n    };\n\n    root.addEventListener('click', (e) => {\n        const button = e.target.closest('[data-action]');\n        if (!button) {\n            return;\n        }\n        const action = button.dataset.action;\n        if (actions[action]) {\n            e.preventDefault();\n            actions[action]();\n        }\n    });\n\n    // Run clock offset calibration (non-blocking).\n    calibrateClockOffset();\n};\n"],"names":["SELECTORS","name","receiveStats","pushStats","receiveTimeoutId","clockOffset","generateBurstId","Date","now","toString","Math","random","slice","resetReceiveStats","burstid","clearReceiveTimeout","count","expected","totalLatency","min","Infinity","max","adjustedTotalLatency","adjustedMin","adjustedMax","errors","errorMessages","seqReceived","Set","resetPushStats","totalRtt","getRoot","document","querySelector","updateStat","value","el","textContent","showRegion","classList","remove","hideRegion","add","showResetButton","section","getFieldValue","defaultValue","val","parseInt","isNaN","formatMs","ms","round","extractErrorMessage","err","message","error","debuginfo","String","addReceiveError","push","clearTimeout","resetReceiveTimeout","setTimeout","missing","updateReceiveDisplay","RECEIVE_TIMEOUT_SEC","countText","avg","adjustedAvg","join","updatePushDisplay","onEventReceived","data","component","area","payload","senttime","seq","total","JSON","stringify","has","latency","adjustedLatency","calibrateClockOffset","async","infoEl","recalibrateLink","toServerSamples","fromServerSamples","i","t1","response","sendTestEvents","t4","t2","servertime","window","console","warn","length","avgToServer","reduce","a","b","avgFromServer","text","threshold","abs","link","useadhoc","delay","Ajax","call","methodname","args","handleReceiveSingle","handleReceiveBurst","validatePushResponse","sentPayload","receivedtime","echo","Number","handlePushBurst","Promise","resolve","startTime","rtt","validationError","handleReceiveReset","handlePushReset","PubSub","subscribe","RealTimeEvents","EVENT","CONNECTION_LOST","root","actions","addEventListener","e","button","target","closest","action","dataset","preventDefault"],"mappings":"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"}