define("realtimeplugin_centrifugo/centrifuge-lazy",["exports"],(function(_exports){function __awaiter(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P((function(resolve){resolve(value)}))).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))}Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.unsubscribedCodes=_exports.subscriptionFlags=_exports.subscribingCodes=_exports.errorCodes=_exports.disconnectedCodes=_exports.connectingCodes=_exports.UnauthorizedError=_exports.SubscriptionState=_exports.Subscription=_exports.State=_exports.Centrifuge=void 0,"function"==typeof SuppressedError&&SuppressedError;var ReflectOwnKeys,events={exports:{}},R="object"==typeof Reflect?Reflect:null,ReflectApply=R&&"function"==typeof R.apply?R.apply:function(target,receiver,args){return Function.prototype.apply.call(target,receiver,args)};ReflectOwnKeys=R&&"function"==typeof R.ownKeys?R.ownKeys:Object.getOwnPropertySymbols?function(target){return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))}:function(target){return Object.getOwnPropertyNames(target)};var NumberIsNaN=Number.isNaN||function(value){return value!=value};function EventEmitter(){EventEmitter.init.call(this)}events.exports=EventEmitter,events.exports.once=function(emitter,name){return new Promise((function(resolve,reject){function errorListener(err){emitter.removeListener(name,resolver),reject(err)}function resolver(){"function"==typeof emitter.removeListener&&emitter.removeListener("error",errorListener),resolve([].slice.call(arguments))}eventTargetAgnosticAddListener(emitter,name,resolver,{once:!0}),"error"!==name&&function(emitter,handler,flags){"function"==typeof emitter.on&&eventTargetAgnosticAddListener(emitter,"error",handler,flags)}(emitter,errorListener,{once:!0})}))},EventEmitter.EventEmitter=EventEmitter,EventEmitter.prototype._events=void 0,EventEmitter.prototype._eventsCount=0,EventEmitter.prototype._maxListeners=void 0;var defaultMaxListeners=10;function checkListener(listener){if("function"!=typeof listener)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof listener)}function _getMaxListeners(that){return void 0===that._maxListeners?EventEmitter.defaultMaxListeners:that._maxListeners}function _addListener(target,type,listener,prepend){var m,events,existing,warning;if(checkListener(listener),void 0===(events=target._events)?(events=target._events=Object.create(null),target._eventsCount=0):(void 0!==events.newListener&&(target.emit("newListener",type,listener.listener?listener.listener:listener),events=target._events),existing=events[type]),void 0===existing)existing=events[type]=listener,++target._eventsCount;else if("function"==typeof existing?existing=events[type]=prepend?[listener,existing]:[existing,listener]:prepend?existing.unshift(listener):existing.push(listener),(m=_getMaxListeners(target))>0&&existing.length>m&&!existing.warned){existing.warned=!0;var w=new Error("Possible EventEmitter memory leak detected. "+existing.length+" "+String(type)+" listeners added. Use emitter.setMaxListeners() to increase limit");w.name="MaxListenersExceededWarning",w.emitter=target,w.type=type,w.count=existing.length,warning=w,console&&console.warn&&console.warn(warning)}return target}function onceWrapper(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function _onceWrap(target,type,listener){var state={fired:!1,wrapFn:void 0,target:target,type:type,listener:listener},wrapped=onceWrapper.bind(state);return wrapped.listener=listener,state.wrapFn=wrapped,wrapped}function _listeners(target,type,unwrap){var events=target._events;if(void 0===events)return[];var evlistener=events[type];return void 0===evlistener?[]:"function"==typeof evlistener?unwrap?[evlistener.listener||evlistener]:[evlistener]:unwrap?function(arr){for(var ret=new Array(arr.length),i=0;i<ret.length;++i)ret[i]=arr[i].listener||arr[i];return ret}(evlistener):arrayClone(evlistener,evlistener.length)}function listenerCount(type){var events=this._events;if(void 0!==events){var evlistener=events[type];if("function"==typeof evlistener)return 1;if(void 0!==evlistener)return evlistener.length}return 0}function arrayClone(arr,n){for(var copy=new Array(n),i=0;i<n;++i)copy[i]=arr[i];return copy}function eventTargetAgnosticAddListener(emitter,name,listener,flags){if("function"==typeof emitter.on)flags.once?emitter.once(name,listener):emitter.on(name,listener);else{if("function"!=typeof emitter.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof emitter);emitter.addEventListener(name,(function wrapListener(arg){flags.once&&emitter.removeEventListener(name,wrapListener),listener(arg)}))}}Object.defineProperty(EventEmitter,"defaultMaxListeners",{enumerable:!0,get:function(){return defaultMaxListeners},set:function(arg){if("number"!=typeof arg||arg<0||NumberIsNaN(arg))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+arg+".");defaultMaxListeners=arg}}),EventEmitter.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},EventEmitter.prototype.setMaxListeners=function(n){if("number"!=typeof n||n<0||NumberIsNaN(n))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+n+".");return this._maxListeners=n,this},EventEmitter.prototype.getMaxListeners=function(){return _getMaxListeners(this)},EventEmitter.prototype.emit=function(type){for(var args=[],i=1;i<arguments.length;i++)args.push(arguments[i]);var doError="error"===type,events=this._events;if(void 0!==events)doError=doError&&void 0===events.error;else if(!doError)return!1;if(doError){var er;if(args.length>0&&(er=args[0]),er instanceof Error)throw er;var err=new Error("Unhandled error."+(er?" ("+er.message+")":""));throw err.context=er,err}var handler=events[type];if(void 0===handler)return!1;if("function"==typeof handler)ReflectApply(handler,this,args);else{var len=handler.length,listeners=arrayClone(handler,len);for(i=0;i<len;++i)ReflectApply(listeners[i],this,args)}return!0},EventEmitter.prototype.addListener=function(type,listener){return _addListener(this,type,listener,!1)},EventEmitter.prototype.on=EventEmitter.prototype.addListener,EventEmitter.prototype.prependListener=function(type,listener){return _addListener(this,type,listener,!0)},EventEmitter.prototype.once=function(type,listener){return checkListener(listener),this.on(type,_onceWrap(this,type,listener)),this},EventEmitter.prototype.prependOnceListener=function(type,listener){return checkListener(listener),this.prependListener(type,_onceWrap(this,type,listener)),this},EventEmitter.prototype.removeListener=function(type,listener){var list,events,position,i,originalListener;if(checkListener(listener),void 0===(events=this._events))return this;if(void 0===(list=events[type]))return this;if(list===listener||list.listener===listener)0==--this._eventsCount?this._events=Object.create(null):(delete events[type],events.removeListener&&this.emit("removeListener",type,list.listener||listener));else if("function"!=typeof list){for(position=-1,i=list.length-1;i>=0;i--)if(list[i]===listener||list[i].listener===listener){originalListener=list[i].listener,position=i;break}if(position<0)return this;0===position?list.shift():function(list,index){for(;index+1<list.length;index++)list[index]=list[index+1];list.pop()}(list,position),1===list.length&&(events[type]=list[0]),void 0!==events.removeListener&&this.emit("removeListener",type,originalListener||listener)}return this},EventEmitter.prototype.off=EventEmitter.prototype.removeListener,EventEmitter.prototype.removeAllListeners=function(type){var listeners,events,i;if(void 0===(events=this._events))return this;if(void 0===events.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==events[type]&&(0==--this._eventsCount?this._events=Object.create(null):delete events[type]),this;if(0===arguments.length){var key,keys=Object.keys(events);for(i=0;i<keys.length;++i)"removeListener"!==(key=keys[i])&&this.removeAllListeners(key);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(listeners=events[type]))this.removeListener(type,listeners);else if(void 0!==listeners)for(i=listeners.length-1;i>=0;i--)this.removeListener(type,listeners[i]);return this},EventEmitter.prototype.listeners=function(type){return _listeners(this,type,!0)},EventEmitter.prototype.rawListeners=function(type){return _listeners(this,type,!1)},EventEmitter.listenerCount=function(emitter,type){return"function"==typeof emitter.listenerCount?emitter.listenerCount(type):listenerCount.call(emitter,type)},EventEmitter.prototype.listenerCount=listenerCount,EventEmitter.prototype.eventNames=function(){return this._eventsCount>0?ReflectOwnKeys(this._events):[]};var x,errorCodes,connectingCodes,disconnectedCodes,subscribingCodes,unsubscribedCodes,subscriptionFlags,State,SubscriptionState,eventsExports=events.exports,EventEmitter$1=(x=eventsExports)&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x.default:x;function isFunction(value){return null!=value&&"function"==typeof value}function backoff(step,min,max){step>31&&(step=31);const interval=function(min,max){return Math.floor(Math.random()*(max-min+1)+min)}(0,Math.min(max,min*Math.pow(2,step)));return Math.min(max,min+interval)}function ttlMilliseconds(ttl){return Math.min(1e3*ttl,2147483647)}_exports.errorCodes=errorCodes,function(errorCodes){errorCodes[errorCodes.timeout=1]="timeout",errorCodes[errorCodes.transportClosed=2]="transportClosed",errorCodes[errorCodes.clientDisconnected=3]="clientDisconnected",errorCodes[errorCodes.clientClosed=4]="clientClosed",errorCodes[errorCodes.clientConnectToken=5]="clientConnectToken",errorCodes[errorCodes.clientRefreshToken=6]="clientRefreshToken",errorCodes[errorCodes.subscriptionUnsubscribed=7]="subscriptionUnsubscribed",errorCodes[errorCodes.subscriptionSubscribeToken=8]="subscriptionSubscribeToken",errorCodes[errorCodes.subscriptionRefreshToken=9]="subscriptionRefreshToken",errorCodes[errorCodes.transportWriteError=10]="transportWriteError",errorCodes[errorCodes.connectionClosed=11]="connectionClosed",errorCodes[errorCodes.badConfiguration=12]="badConfiguration"}(errorCodes||(_exports.errorCodes=errorCodes={})),_exports.connectingCodes=connectingCodes,function(connectingCodes){connectingCodes[connectingCodes.connectCalled=0]="connectCalled",connectingCodes[connectingCodes.transportClosed=1]="transportClosed",connectingCodes[connectingCodes.noPing=2]="noPing",connectingCodes[connectingCodes.subscribeTimeout=3]="subscribeTimeout",connectingCodes[connectingCodes.unsubscribeError=4]="unsubscribeError"}(connectingCodes||(_exports.connectingCodes=connectingCodes={})),_exports.disconnectedCodes=disconnectedCodes,function(disconnectedCodes){disconnectedCodes[disconnectedCodes.disconnectCalled=0]="disconnectCalled",disconnectedCodes[disconnectedCodes.unauthorized=1]="unauthorized",disconnectedCodes[disconnectedCodes.badProtocol=2]="badProtocol",disconnectedCodes[disconnectedCodes.messageSizeLimit=3]="messageSizeLimit"}(disconnectedCodes||(_exports.disconnectedCodes=disconnectedCodes={})),_exports.subscribingCodes=subscribingCodes,function(subscribingCodes){subscribingCodes[subscribingCodes.subscribeCalled=0]="subscribeCalled",subscribingCodes[subscribingCodes.transportClosed=1]="transportClosed"}(subscribingCodes||(_exports.subscribingCodes=subscribingCodes={})),_exports.unsubscribedCodes=unsubscribedCodes,function(unsubscribedCodes){unsubscribedCodes[unsubscribedCodes.unsubscribeCalled=0]="unsubscribeCalled",unsubscribedCodes[unsubscribedCodes.unauthorized=1]="unauthorized",unsubscribedCodes[unsubscribedCodes.clientClosed=2]="clientClosed"}(unsubscribedCodes||(_exports.unsubscribedCodes=unsubscribedCodes={})),_exports.subscriptionFlags=subscriptionFlags,function(subscriptionFlags){subscriptionFlags[subscriptionFlags.channelCompaction=1]="channelCompaction"}(subscriptionFlags||(_exports.subscriptionFlags=subscriptionFlags={})),_exports.State=State,function(State){State.Disconnected="disconnected",State.Connecting="connecting",State.Connected="connected"}(State||(_exports.State=State={})),_exports.SubscriptionState=SubscriptionState,function(SubscriptionState){SubscriptionState.Unsubscribed="unsubscribed",SubscriptionState.Subscribing="subscribing",SubscriptionState.Subscribed="subscribed"}(SubscriptionState||(_exports.SubscriptionState=SubscriptionState={}));class Subscription extends EventEmitter$1{constructor(centrifuge,channel,options){super(),this._resubscribeTimeout=null,this._refreshTimeout=null,this.channel=channel,this.state=SubscriptionState.Unsubscribed,this._centrifuge=centrifuge,this._token="",this._getToken=null,this._data=null,this._getData=null,this._recover=!1,this._offset=null,this._epoch=null,this._id=0,this._recoverable=!1,this._positioned=!1,this._joinLeave=!1,this._minResubscribeDelay=500,this._maxResubscribeDelay=2e4,this._resubscribeTimeout=null,this._resubscribeAttempts=0,this._promises={},this._promiseId=0,this._inflight=!1,this._refreshTimeout=null,this._delta="",this._delta_negotiated=!1,this._tagsFilter=null,this._prevValue=null,this._unsubPromise=Promise.resolve(),this._setOptions(options),this._centrifuge._debugEnabled?(this.on("state",(ctx=>{this._debug("subscription state",channel,ctx.oldState,"->",ctx.newState)})),this.on("error",(ctx=>{this._debug("subscription error",channel,ctx)}))):this.on("error",(function(){Function.prototype()}))}ready(timeout){return this.state===SubscriptionState.Unsubscribed?Promise.reject({code:errorCodes.subscriptionUnsubscribed,message:this.state}):this.state===SubscriptionState.Subscribed?Promise.resolve():new Promise(((res,rej)=>{const ctx={resolve:res,reject:rej};timeout&&(ctx.timeout=setTimeout((function(){rej({code:errorCodes.timeout,message:"timeout"})}),timeout)),this._promises[this._nextPromiseId()]=ctx}))}subscribe(){this._isSubscribed()||(this._resubscribeAttempts=0,this._setSubscribing(subscribingCodes.subscribeCalled,"subscribe called"))}unsubscribe(){this._unsubPromise=this._setUnsubscribed(unsubscribedCodes.unsubscribeCalled,"unsubscribe called",!0)}publish(data){return __awaiter(this,void 0,void 0,(function*(){return yield this._methodCall(),this._centrifuge.publish(this.channel,data)}))}presence(){return __awaiter(this,void 0,void 0,(function*(){return yield this._methodCall(),this._centrifuge.presence(this.channel)}))}presenceStats(){return __awaiter(this,void 0,void 0,(function*(){return yield this._methodCall(),this._centrifuge.presenceStats(this.channel)}))}history(opts){return __awaiter(this,void 0,void 0,(function*(){return yield this._methodCall(),this._centrifuge.history(this.channel,opts)}))}setTagsFilter(tagsFilter){if(tagsFilter&&this._delta)throw new Error("cannot use delta and tagsFilter together");this._tagsFilter=tagsFilter}setData(data){this._data=data}_methodCall(){return this._isSubscribed()?Promise.resolve():this._isUnsubscribed()?Promise.reject({code:errorCodes.subscriptionUnsubscribed,message:this.state}):new Promise(((resolve,reject)=>{const timeoutDuration=this._centrifuge._config.timeout,timeout=setTimeout((()=>{reject({code:errorCodes.timeout,message:"timeout"})}),timeoutDuration);this._promises[this._nextPromiseId()]={timeout:timeout,resolve:resolve,reject:reject}}))}_nextPromiseId(){return++this._promiseId}_needRecover(){return!0===this._recover}_isUnsubscribed(){return this.state===SubscriptionState.Unsubscribed}_isSubscribing(){return this.state===SubscriptionState.Subscribing}_isSubscribed(){return this.state===SubscriptionState.Subscribed}_setState(newState){if(this.state!==newState){const oldState=this.state;return this.state=newState,this.emit("state",{newState:newState,oldState:oldState,channel:this.channel}),!0}return!1}_usesToken(){return""!==this._token||null!==this._getToken}_clearSubscribingState(){this._resubscribeAttempts=0,this._clearResubscribeTimeout()}_clearSubscribedState(){this._clearRefreshTimeout()}_setSubscribed(result){if(!this._isSubscribing())return;this._clearSubscribingState(),result.id&&(this._id=result.id),result.recoverable&&(this._recover=!0,this._offset=result.offset||0,this._epoch=result.epoch||""),result.delta?this._delta_negotiated=!0:this._delta_negotiated=!1,this._setState(SubscriptionState.Subscribed);const ctx=this._centrifuge._getSubscribeContext(this.channel,result);this.emit("subscribed",ctx),this._resolvePromises();const pubs=result.publications;if(pubs&&pubs.length>0)for(const i in pubs)pubs.hasOwnProperty(i)&&this._handlePublication(pubs[i]);!0===result.expires&&(this._refreshTimeout=setTimeout((()=>this._refresh()),ttlMilliseconds(result.ttl)))}_setSubscribing(code,reason){return __awaiter(this,void 0,void 0,(function*(){this._isSubscribing()||(this._isSubscribed()&&this._clearSubscribedState(),this._setState(SubscriptionState.Subscribing)&&this.emit("subscribing",{channel:this.channel,code:code,reason:reason}),this._centrifuge._transport&&this._centrifuge._transport.emulation()&&(yield this._unsubPromise),this._isSubscribing()&&this._subscribe())}))}_subscribe(){return this._debug("subscribing on",this.channel),this._isTransportOpen()?this._inflight?null:(this._inflight=!0,this._canSubscribeWithoutGettingToken()?this._subscribeWithoutToken():(this._getSubscriptionToken().then((token=>this._handleTokenResponse(token))).catch((e=>this._handleTokenError(e))),null)):(this._debug("delay subscribe on",this.channel,"till connected"),null)}_isTransportOpen(){return this._centrifuge._transportIsOpen}_canSubscribeWithoutGettingToken(){return!this._usesToken()||!!this._token}_subscribeWithoutToken(){return this._getData?(this._getDataAndSubscribe(this._token),null):this._sendSubscribe(this._token)}_getDataAndSubscribe(token){this._getData?this._getData({channel:this.channel}).then((data=>{this._isSubscribing()?(this._data=data,this._sendSubscribe(token)):this._inflight=!1})).catch((e=>this._handleGetDataError(e))):this._inflight=!1}_handleGetDataError(error){if(this._isSubscribing()){if(error instanceof UnauthorizedError)return this._inflight=!1,void this._failUnauthorized();this.emit("error",{type:"subscribeData",channel:this.channel,error:{code:errorCodes.badConfiguration,message:(null==error?void 0:error.toString())||""}}),this._inflight=!1,this._scheduleResubscribe()}else this._inflight=!1}_handleTokenResponse(token){if(this._isSubscribing()){if(!token)return this._inflight=!1,void this._failUnauthorized();this._token=token,this._getData?this._getDataAndSubscribe(token):this._sendSubscribe(token)}else this._inflight=!1}_handleTokenError(error){if(this._isSubscribing()){if(error instanceof UnauthorizedError)return this._inflight=!1,void this._failUnauthorized();this.emit("error",{type:"subscribeToken",channel:this.channel,error:{code:errorCodes.subscriptionSubscribeToken,message:(null==error?void 0:error.toString())||""}}),this._inflight=!1,this._scheduleResubscribe()}else this._inflight=!1}_sendSubscribe(token){if(!this._isTransportOpen())return this._inflight=!1,null;const cmd=this._buildSubscribeCommand(token);return this._centrifuge._call(cmd).then((resolveCtx=>{this._inflight=!1;const result=resolveCtx.reply.subscribe;this._handleSubscribeResponse(result),resolveCtx.next&&resolveCtx.next()}),(rejectCtx=>{this._inflight=!1,this._handleSubscribeError(rejectCtx.error),rejectCtx.next&&rejectCtx.next()})),cmd}_buildSubscribeCommand(token){const req={channel:this.channel};if(token&&(req.token=token),this._data&&(req.data=this._data),this._positioned&&(req.positioned=!0),this._recoverable&&(req.recoverable=!0),this._joinLeave&&(req.join_leave=!0),req.flag=subscriptionFlags.channelCompaction,this._needRecover()){req.recover=!0;const offset=this._getOffset();offset&&(req.offset=offset);const epoch=this._getEpoch();epoch&&(req.epoch=epoch)}return this._delta&&(req.delta=this._delta),this._tagsFilter&&(req.tf=this._tagsFilter),{subscribe:req}}_debug(){this._centrifuge._debug(...arguments)}_handleSubscribeError(error){this._isSubscribing()&&(error.code!==errorCodes.timeout?this._subscribeError(error):this._centrifuge._disconnect(connectingCodes.subscribeTimeout,"subscribe timeout",!0))}_handleSubscribeResponse(result){this._isSubscribing()&&this._setSubscribed(result)}_setUnsubscribed(code,reason,sendUnsubscribe){if(this._isUnsubscribed())return Promise.resolve();let promise=Promise.resolve();return this._isSubscribed()?(sendUnsubscribe&&(promise=this._centrifuge._unsubscribe(this)),this._clearSubscribedState()):this._isSubscribing()&&(this._inflight&&sendUnsubscribe&&(promise=this._centrifuge._unsubscribe(this)),this._clearSubscribingState()),this._inflight=!1,this._setState(SubscriptionState.Unsubscribed)&&this.emit("unsubscribed",{channel:this.channel,code:code,reason:reason}),this._rejectPromises({code:errorCodes.subscriptionUnsubscribed,message:this.state}),promise}_handlePublication(pub){if(this._delta&&this._delta_negotiated){const{newData:newData,newPrevValue:newPrevValue}=this._centrifuge._codec.applyDeltaIfNeeded(pub,this._prevValue);pub.data=newData,this._prevValue=newPrevValue}const ctx=this._centrifuge._getPublicationContext(this.channel,pub);this.emit("publication",ctx),pub.offset&&(this._offset=pub.offset)}_handleJoin(join){const info=this._centrifuge._getJoinLeaveContext(join.info);this.emit("join",{channel:this.channel,info:info})}_handleLeave(leave){const info=this._centrifuge._getJoinLeaveContext(leave.info);this.emit("leave",{channel:this.channel,info:info})}_resolvePromises(){for(const id in this._promises)this._promises.hasOwnProperty(id)&&(this._promises[id].timeout&&clearTimeout(this._promises[id].timeout),this._promises[id].resolve(),delete this._promises[id])}_rejectPromises(err){for(const id in this._promises)this._promises.hasOwnProperty(id)&&(this._promises[id].timeout&&clearTimeout(this._promises[id].timeout),this._promises[id].reject(err),delete this._promises[id])}_scheduleResubscribe(){if(!this._isSubscribing())return void this._debug("not in subscribing state, skip resubscribe scheduling",this.channel);const self=this,delay=this._getResubscribeDelay();this._resubscribeTimeout=setTimeout((function(){self._isSubscribing()&&self._subscribe()}),delay),this._debug("resubscribe scheduled after "+delay,this.channel)}_subscribeError(err){if(this._isSubscribing())if(err.code<100||109===err.code||!0===err.temporary){109===err.code&&(this._token="");const errContext={channel:this.channel,type:"subscribe",error:err};this._centrifuge.state===State.Connected&&this.emit("error",errContext),this._scheduleResubscribe()}else this._setUnsubscribed(err.code,err.message,!1)}_getResubscribeDelay(){const delay=backoff(this._resubscribeAttempts,this._minResubscribeDelay,this._maxResubscribeDelay);return this._resubscribeAttempts++,delay}_setOptions(options){if(options){if(options.since&&(this._offset=options.since.offset||0,this._epoch=options.since.epoch||"",this._recover=!0),options.data&&(this._data=options.data),options.getData&&(this._getData=options.getData),void 0!==options.minResubscribeDelay&&(this._minResubscribeDelay=options.minResubscribeDelay),void 0!==options.maxResubscribeDelay&&(this._maxResubscribeDelay=options.maxResubscribeDelay),options.token&&(this._token=options.token),options.getToken&&(this._getToken=options.getToken),!0===options.positioned&&(this._positioned=!0),!0===options.recoverable&&(this._recoverable=!0),!0===options.joinLeave&&(this._joinLeave=!0),options.delta){if("fossil"!==options.delta)throw new Error("unsupported delta format");this._delta=options.delta}if(options.tagsFilter&&(this._tagsFilter=options.tagsFilter),this._tagsFilter&&this._delta)throw new Error("cannot use delta and tagsFilter together")}}_getOffset(){const offset=this._offset;return null!==offset?offset:0}_getEpoch(){const epoch=this._epoch;return null!==epoch?epoch:""}_clearRefreshTimeout(){null!==this._refreshTimeout&&(clearTimeout(this._refreshTimeout),this._refreshTimeout=null)}_clearResubscribeTimeout(){null!==this._resubscribeTimeout&&(clearTimeout(this._resubscribeTimeout),this._resubscribeTimeout=null)}_getSubscriptionToken(){this._debug("get subscription token for channel",this.channel);const ctx={channel:this.channel},getToken=this._getToken;return null===getToken?(this.emit("error",{type:"configuration",channel:this.channel,error:{code:errorCodes.badConfiguration,message:"provide a function to get channel subscription token"}}),Promise.reject(new UnauthorizedError(""))):getToken(ctx)}_refresh(){this._clearRefreshTimeout();const self=this;this._getSubscriptionToken().then((function(token){if(!self._isSubscribed())return;if(!token)return void self._failUnauthorized();self._token=token;const msg={sub_refresh:{channel:self.channel,token:token}};self._centrifuge._call(msg).then((resolveCtx=>{const result=resolveCtx.reply.sub_refresh;self._refreshResponse(result),resolveCtx.next&&resolveCtx.next()}),(rejectCtx=>{self._refreshError(rejectCtx.error),rejectCtx.next&&rejectCtx.next()}))})).catch((function(e){e instanceof UnauthorizedError?self._failUnauthorized():(self.emit("error",{type:"refreshToken",channel:self.channel,error:{code:errorCodes.subscriptionRefreshToken,message:void 0!==e?e.toString():""}}),self._refreshTimeout=setTimeout((()=>self._refresh()),self._getRefreshRetryDelay()))}))}_refreshResponse(result){this._isSubscribed()&&(this._debug("subscription token refreshed, channel",this.channel),this._clearRefreshTimeout(),!0===result.expires&&(this._refreshTimeout=setTimeout((()=>this._refresh()),ttlMilliseconds(result.ttl))))}_refreshError(err){this._isSubscribed()&&(err.code<100||!0===err.temporary?(this.emit("error",{type:"refresh",channel:this.channel,error:err}),this._refreshTimeout=setTimeout((()=>this._refresh()),this._getRefreshRetryDelay())):this._setUnsubscribed(err.code,err.message,!0))}_getRefreshRetryDelay(){return backoff(0,1e4,2e4)}_failUnauthorized(){this._setUnsubscribed(unsubscribedCodes.unauthorized,"unauthorized",!0)}}_exports.Subscription=Subscription;class SockjsTransport{constructor(endpoint,options){this.endpoint=endpoint,this.options=options,this._transport=null}name(){return"sockjs"}subName(){return"sockjs-"+this._transport.transport}emulation(){return!1}supported(){return null!==this.options.sockjs}initialize(_protocol,callbacks){this._transport=new this.options.sockjs(this.endpoint,null,this.options.sockjsOptions),this._transport.onopen=()=>{callbacks.onOpen()},this._transport.onerror=e=>{callbacks.onError(e)},this._transport.onclose=closeEvent=>{callbacks.onClose(closeEvent)},this._transport.onmessage=event=>{callbacks.onMessage(event.data)}}close(){this._transport.close()}send(data){this._transport.send(data)}}class WebsocketTransport{constructor(endpoint,options){this.endpoint=endpoint,this.options=options,this._transport=null}name(){return"websocket"}subName(){return"websocket"}emulation(){return!1}supported(){return void 0!==this.options.websocket&&null!==this.options.websocket}initialize(protocol,callbacks){let subProtocol="";"protobuf"===protocol&&(subProtocol="centrifuge-protobuf"),this._transport=""!==subProtocol?new this.options.websocket(this.endpoint,subProtocol):new this.options.websocket(this.endpoint),"protobuf"===protocol&&(this._transport.binaryType="arraybuffer"),this._transport.onopen=()=>{callbacks.onOpen()},this._transport.onerror=e=>{callbacks.onError(e)},this._transport.onclose=closeEvent=>{callbacks.onClose(closeEvent)},this._transport.onmessage=event=>{callbacks.onMessage(event.data)}}close(){this._transport.close()}send(data){this._transport.send(data)}}class HttpStreamTransport{constructor(endpoint,options){this.endpoint=endpoint,this.options=options,this._abortController=null,this._utf8decoder=new TextDecoder,this._protocol="json"}name(){return"http_stream"}subName(){return"http_stream"}emulation(){return!0}_handleErrors(response){if(!response.ok)throw new Error(response.status);return response}_fetchEventTarget(self,endpoint,options){const eventTarget=new EventTarget;return(0,self.options.fetch)(endpoint,options).then(self._handleErrors).then((response=>{eventTarget.dispatchEvent(new Event("open"));let jsonStreamBuf="",jsonStreamPos=0,protoStreamBuf=new Uint8Array;const reader=response.body.getReader();return new self.options.readableStream({start:controller=>function pump(){return reader.read().then((_ref=>{let{done:done,value:value}=_ref;if(done)return eventTarget.dispatchEvent(new Event("close")),void controller.close();try{if("json"===self._protocol)for(jsonStreamBuf+=self._utf8decoder.decode(value);jsonStreamPos<jsonStreamBuf.length;)if("\n"===jsonStreamBuf[jsonStreamPos]){const line=jsonStreamBuf.substring(0,jsonStreamPos);eventTarget.dispatchEvent(new MessageEvent("message",{data:line})),jsonStreamBuf=jsonStreamBuf.substring(jsonStreamPos+1),jsonStreamPos=0}else++jsonStreamPos;else{const mergedArray=new Uint8Array(protoStreamBuf.length+value.length);for(mergedArray.set(protoStreamBuf),mergedArray.set(value,protoStreamBuf.length),protoStreamBuf=mergedArray;;){const result=self.options.decoder.decodeReply(protoStreamBuf);if(!result.ok)break;{const data=protoStreamBuf.slice(0,result.pos);eventTarget.dispatchEvent(new MessageEvent("message",{data:data})),protoStreamBuf=protoStreamBuf.slice(result.pos)}}}}catch(error){return eventTarget.dispatchEvent(new Event("error",{detail:error})),eventTarget.dispatchEvent(new Event("close")),void controller.close()}pump()})).catch((function(e){eventTarget.dispatchEvent(new Event("error",{detail:e})),eventTarget.dispatchEvent(new Event("close")),controller.close()}))}()})})).catch((error=>{eventTarget.dispatchEvent(new Event("error",{detail:error})),eventTarget.dispatchEvent(new Event("close"))})),eventTarget}supported(){return null!==this.options.fetch&&null!==this.options.readableStream&&"undefined"!=typeof TextDecoder&&"undefined"!=typeof AbortController&&"undefined"!=typeof EventTarget&&"undefined"!=typeof Event&&"undefined"!=typeof MessageEvent&&"undefined"!=typeof Error}initialize(protocol,callbacks,initialData){let headers,body;this._protocol=protocol,this._abortController=new AbortController,"json"===protocol?(headers={Accept:"application/json","Content-Type":"application/json"},body=initialData):(headers={Accept:"application/octet-stream","Content-Type":"application/octet-stream"},body=initialData);const fetchOptions={method:"POST",headers:headers,body:body,mode:"cors",credentials:"same-origin",signal:this._abortController.signal},eventTarget=this._fetchEventTarget(this,this.endpoint,fetchOptions);eventTarget.addEventListener("open",(()=>{callbacks.onOpen()})),eventTarget.addEventListener("error",(e=>{this._abortController.abort(),callbacks.onError(e)})),eventTarget.addEventListener("close",(()=>{this._abortController.abort(),callbacks.onClose({code:4,reason:"connection closed"})})),eventTarget.addEventListener("message",(e=>{callbacks.onMessage(e.data)}))}close(){this._abortController.abort()}send(data,session,node){let headers,body;const req={session:session,node:node,data:data};"json"===this._protocol?(headers={"Content-Type":"application/json"},body=JSON.stringify(req)):(headers={"Content-Type":"application/octet-stream"},body=this.options.encoder.encodeEmulationRequest(req));const fetchOptions={method:"POST",headers:headers,body:body,mode:"cors",credentials:"same-origin"};(0,this.options.fetch)(this.options.emulationEndpoint,fetchOptions)}}class SseTransport{constructor(endpoint,options){this.endpoint=endpoint,this.options=options,this._protocol="json",this._transport=null,this._onClose=null}name(){return"sse"}subName(){return"sse"}emulation(){return!0}supported(){return null!==this.options.eventsource&&null!==this.options.fetch}initialize(_protocol,callbacks,initialData){let url;url=globalThis&&globalThis.document&&globalThis.document.baseURI?new URL(this.endpoint,globalThis.document.baseURI):new URL(this.endpoint),url.searchParams.append("cf_connect",initialData);const eventSource=new this.options.eventsource(url.toString(),{});this._transport=eventSource;eventSource.onopen=function(){callbacks.onOpen()},eventSource.onerror=function(e){eventSource.close(),callbacks.onError(e),callbacks.onClose({code:4,reason:"connection closed"})},eventSource.onmessage=function(e){callbacks.onMessage(e.data)},this._onClose=function(){callbacks.onClose({code:4,reason:"connection closed"})}}close(){this._transport.close(),null!==this._onClose&&this._onClose()}send(data,session,node){const req={session:session,node:node,data:data},fetchOptions={method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(req),mode:"cors",credentials:"same-origin"};(0,this.options.fetch)(this.options.emulationEndpoint,fetchOptions)}}class WebtransportTransport{constructor(endpoint,options){this.endpoint=endpoint,this.options=options,this._transport=null,this._stream=null,this._writer=null,this._utf8decoder=new TextDecoder,this._protocol="json"}name(){return"webtransport"}subName(){return"webtransport"}emulation(){return!1}supported(){return void 0!==this.options.webtransport&&null!==this.options.webtransport}initialize(protocol,callbacks){return __awaiter(this,void 0,void 0,(function*(){let url;url=globalThis&&globalThis.document&&globalThis.document.baseURI?new URL(this.endpoint,globalThis.document.baseURI):new URL(this.endpoint),"protobuf"===protocol&&url.searchParams.append("cf_protocol","protobuf"),this._protocol=protocol;const eventTarget=new EventTarget;this._transport=new this.options.webtransport(url.toString()),this._transport.closed.then((()=>{callbacks.onClose({code:4,reason:"connection closed"})})).catch((()=>{callbacks.onClose({code:4,reason:"connection closed"})}));try{yield this._transport.ready}catch(_a){return void this.close()}let stream;try{stream=yield this._transport.createBidirectionalStream()}catch(_b){return void this.close()}this._stream=stream,this._writer=this._stream.writable.getWriter(),eventTarget.addEventListener("close",(()=>{callbacks.onClose({code:4,reason:"connection closed"})})),eventTarget.addEventListener("message",(e=>{callbacks.onMessage(e.data)})),this._startReading(eventTarget),callbacks.onOpen()}))}_startReading(eventTarget){return __awaiter(this,void 0,void 0,(function*(){const reader=this._stream.readable.getReader();let jsonStreamBuf="",jsonStreamPos=0,protoStreamBuf=new Uint8Array;try{for(;;){const{done:done,value:value}=yield reader.read();if(value.length>0)if("json"===this._protocol)for(jsonStreamBuf+=this._utf8decoder.decode(value);jsonStreamPos<jsonStreamBuf.length;)if("\n"===jsonStreamBuf[jsonStreamPos]){const line=jsonStreamBuf.substring(0,jsonStreamPos);eventTarget.dispatchEvent(new MessageEvent("message",{data:line})),jsonStreamBuf=jsonStreamBuf.substring(jsonStreamPos+1),jsonStreamPos=0}else++jsonStreamPos;else{const mergedArray=new Uint8Array(protoStreamBuf.length+value.length);for(mergedArray.set(protoStreamBuf),mergedArray.set(value,protoStreamBuf.length),protoStreamBuf=mergedArray;;){const result=this.options.decoder.decodeReply(protoStreamBuf);if(!result.ok)break;{const data=protoStreamBuf.slice(0,result.pos);eventTarget.dispatchEvent(new MessageEvent("message",{data:data})),protoStreamBuf=protoStreamBuf.slice(result.pos)}}}if(done)break}}catch(_a){eventTarget.dispatchEvent(new Event("close"))}}))}close(){return __awaiter(this,void 0,void 0,(function*(){try{this._writer&&(yield this._writer.close()),this._transport.close()}catch(e){}}))}send(data){return __awaiter(this,void 0,void 0,(function*(){let binary;binary="json"===this._protocol?(new TextEncoder).encode(data+"\n"):data;try{yield this._writer.write(binary)}catch(e){this.close()}}))}}const zValue=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,-1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,36,-1,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,-1,-1,-1,63,-1];class Reader{constructor(array){this.a=array,this.pos=0}haveBytes(){return this.pos<this.a.length}getByte(){const b=this.a[this.pos];if(this.pos++,this.pos>this.a.length)throw new RangeError("out of bounds");return b}getChar(){return String.fromCharCode(this.getByte())}getInt(){let c,v=0;for(;this.haveBytes()&&(c=zValue[127&this.getByte()])>=0;)v=(v<<6)+c;return this.pos--,v>>>0}}class Writer{constructor(){this.a=[]}toByteArray(sourceType){return Array.isArray(sourceType)?this.a:new Uint8Array(this.a)}putArray(a,start,end){for(let i=start;i<end;i++)this.a.push(a[i])}}function checksum(arr){let sum0=0,sum1=0,sum2=0,sum3=0,z=0,N=arr.length;for(;N>=16;)sum0=sum0+arr[z+0]|0,sum1=sum1+arr[z+1]|0,sum2=sum2+arr[z+2]|0,sum3=sum3+arr[z+3]|0,sum0=sum0+arr[z+4]|0,sum1=sum1+arr[z+5]|0,sum2=sum2+arr[z+6]|0,sum3=sum3+arr[z+7]|0,sum0=sum0+arr[z+8]|0,sum1=sum1+arr[z+9]|0,sum2=sum2+arr[z+10]|0,sum3=sum3+arr[z+11]|0,sum0=sum0+arr[z+12]|0,sum1=sum1+arr[z+13]|0,sum2=sum2+arr[z+14]|0,sum3=sum3+arr[z+15]|0,z+=16,N-=16;for(;N>=4;)sum0=sum0+arr[z+0]|0,sum1=sum1+arr[z+1]|0,sum2=sum2+arr[z+2]|0,sum3=sum3+arr[z+3]|0,z+=4,N-=4;switch(sum3=((sum3+(sum2<<8)|0)+(sum1<<16)|0)+(sum0<<24)|0,N){case 3:sum3=sum3+(arr[z+2]<<8)|0;case 2:sum3=sum3+(arr[z+1]<<16)|0;case 1:sum3=sum3+(arr[z+0]<<24)|0}return sum3>>>0}class JsonCodec{name(){return"json"}encodeCommands(commands){return commands.map((c=>JSON.stringify(c))).join("\n")}decodeReplies(data){return data.trim().split("\n").map((r=>JSON.parse(r)))}applyDeltaIfNeeded(pub,prevValue){let newData,newPrevValue;if(pub.delta){const valueArray=function(source,delta){let total=0;const zDelta=new Reader(delta),lenSrc=source.length,lenDelta=delta.length,limit=zDelta.getInt();if("\n"!==zDelta.getChar())throw new Error("size integer not terminated by '\\n'");const zOut=new Writer;for(;zDelta.haveBytes();){const cnt=zDelta.getInt();let ofst;switch(zDelta.getChar()){case"@":if(ofst=zDelta.getInt(),zDelta.haveBytes()&&","!==zDelta.getChar())throw new Error("copy command not terminated by ','");if(total+=cnt,total>limit)throw new Error("copy exceeds output file size");if(ofst+cnt>lenSrc)throw new Error("copy extends past end of input");zOut.putArray(source,ofst,ofst+cnt);break;case":":if(total+=cnt,total>limit)throw new Error("insert command gives an output larger than predicted");if(cnt>lenDelta)throw new Error("insert count exceeds size of delta");zOut.putArray(zDelta.a,zDelta.pos,zDelta.pos+cnt),zDelta.pos+=cnt;break;case";":{const out=zOut.toByteArray(source);if(cnt!==checksum(out))throw new Error("bad checksum");if(total!==limit)throw new Error("generated size does not match predicted size");return out}default:throw new Error("unknown delta operator")}}throw new Error("unterminated delta")}(prevValue,(new TextEncoder).encode(pub.data));newData=JSON.parse((new TextDecoder).decode(valueArray)),newPrevValue=valueArray}else newData=JSON.parse(pub.data),newPrevValue=(new TextEncoder).encode(pub.data);return{newData:newData,newPrevValue:newPrevValue}}}const defaults={headers:{},token:"",getToken:null,data:null,getData:null,debug:!1,name:"js",version:"",fetch:null,readableStream:null,websocket:null,eventsource:null,sockjs:null,sockjsOptions:{},emulationEndpoint:"/emulation",minReconnectDelay:500,maxReconnectDelay:2e4,timeout:5e3,maxServerPingDelay:1e4,networkEventTarget:null};class UnauthorizedError extends Error{constructor(message){super(message),this.name=this.constructor.name}}_exports.UnauthorizedError=UnauthorizedError;class Centrifuge extends EventEmitter$1{constructor(endpoint,options){super(),this._reconnectTimeout=null,this._refreshTimeout=null,this._serverPingTimeout=null,this.state=State.Disconnected,this._transportIsOpen=!1,this._endpoint=endpoint,this._emulation=!1,this._transports=[],this._currentTransportIndex=0,this._triedAllTransports=!1,this._transportWasOpen=!1,this._transport=null,this._transportId=0,this._deviceWentOffline=!1,this._transportClosed=!0,this._codec=new JsonCodec,this._reconnecting=!1,this._reconnectTimeout=null,this._reconnectAttempts=0,this._client=null,this._session="",this._node="",this._subs={},this._serverSubs={},this._commandId=0,this._commands=[],this._batching=!1,this._refreshRequired=!1,this._refreshTimeout=null,this._callbacks={},this._token="",this._data=null,this._dispatchPromise=Promise.resolve(),this._serverPing=0,this._serverPingTimeout=null,this._sendPong=!1,this._promises={},this._promiseId=0,this._debugEnabled=!1,this._networkEventsSet=!1,this._config=Object.assign(Object.assign({},defaults),options),this._configure(),this._debugEnabled?(this.on("state",(ctx=>{this._debug("client state",ctx.oldState,"->",ctx.newState)})),this.on("error",(ctx=>{this._debug("client error",ctx)}))):this.on("error",(function(){Function.prototype()}))}newSubscription(channel,options){if(null!==this.getSubscription(channel))throw new Error("Subscription to the channel "+channel+" already exists");const sub=new Subscription(this,channel,options);return this._subs[channel]=sub,sub}getSubscription(channel){return this._getSub(channel)}removeSubscription(sub){sub&&(sub.state!==SubscriptionState.Unsubscribed&&sub.unsubscribe(),this._removeSubscription(sub))}subscriptions(){return this._subs}ready(timeout){return __awaiter(this,void 0,void 0,(function*(){switch(this.state){case State.Disconnected:throw{code:errorCodes.clientDisconnected,message:"client disconnected"};case State.Connected:return;default:return new Promise(((resolve,reject)=>{const ctx={resolve:resolve,reject:reject};timeout&&(ctx.timeout=setTimeout((()=>{reject({code:errorCodes.timeout,message:"timeout"})}),timeout)),this._promises[this._nextPromiseId()]=ctx}))}}))}connect(){this._isConnected()?this._debug("connect called when already connected"):this._isConnecting()?this._debug("connect called when already connecting"):(this._debug("connect called"),this._reconnectAttempts=0,this._startConnecting())}disconnect(){this._disconnect(disconnectedCodes.disconnectCalled,"disconnect called",!1)}setToken(token){this._token=token}setData(data){this._data=data}setHeaders(headers){this._config.headers=headers}send(data){return __awaiter(this,void 0,void 0,(function*(){const cmd={send:{data:data}};yield this._methodCall();if(!this._transportSendCommands([cmd]))throw this._createErrorObject(errorCodes.transportWriteError,"transport write error")}))}rpc(method,data){return __awaiter(this,void 0,void 0,(function*(){const cmd={rpc:{method:method,data:data}};yield this._methodCall();return{data:(yield this._callPromise(cmd,(reply=>reply.rpc))).data}}))}publish(channel,data){return __awaiter(this,void 0,void 0,(function*(){const cmd={publish:{channel:channel,data:data}};return yield this._methodCall(),yield this._callPromise(cmd,(()=>({}))),{}}))}history(channel,options){return __awaiter(this,void 0,void 0,(function*(){const cmd={history:this._getHistoryRequest(channel,options)};yield this._methodCall();const result=yield this._callPromise(cmd,(reply=>reply.history)),publications=[];if(result.publications)for(let i=0;i<result.publications.length;i++)publications.push(this._getPublicationContext(channel,result.publications[i]));return{publications:publications,epoch:result.epoch||"",offset:result.offset||0}}))}presence(channel){return __awaiter(this,void 0,void 0,(function*(){const cmd={presence:{channel:channel}};yield this._methodCall();const clients=(yield this._callPromise(cmd,(reply=>reply.presence))).presence;for(const clientId in clients)if(Object.prototype.hasOwnProperty.call(clients,clientId)){const rawClient=clients[clientId],connInfo=rawClient.conn_info,chanInfo=rawClient.chan_info;connInfo&&(rawClient.connInfo=connInfo),chanInfo&&(rawClient.chanInfo=chanInfo)}return{clients:clients}}))}presenceStats(channel){return __awaiter(this,void 0,void 0,(function*(){const cmd={presence_stats:{channel:channel}};yield this._methodCall();const result=yield this._callPromise(cmd,(reply=>reply.presence_stats));return{numUsers:result.num_users,numClients:result.num_clients}}))}startBatching(){this._batching=!0}stopBatching(){const self=this;Promise.resolve().then((function(){Promise.resolve().then((function(){self._batching=!1,self._flush()}))}))}_debug(){if(this._debugEnabled){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];!function(level,args){if(globalThis.console){const logger=globalThis.console[level];isFunction(logger)&&logger.apply(globalThis.console,args)}}("debug",args)}}_codecName(){return this._codec.name()}_formatOverride(){}_configure(){if(!("Promise"in globalThis))throw new Error("Promise polyfill required");if(!this._endpoint)throw new Error("endpoint configuration required");if(null!==this._config.token&&(this._token=this._config.token),null!==this._config.data&&(this._data=this._config.data),this._codec=new JsonCodec,this._formatOverride(),(!0===this._config.debug||"undefined"!=typeof localStorage&&"function"==typeof localStorage.getItem&&localStorage.getItem("centrifuge.debug"))&&(this._debugEnabled=!0),this._debug("config",this._config),"string"==typeof this._endpoint);else{if(!Array.isArray(this._endpoint))throw new Error("unsupported url configuration type: only string or array of objects are supported");this._transports=this._endpoint,this._emulation=!0;for(const i in this._transports)if(this._transports.hasOwnProperty(i)){const transportConfig=this._transports[i];if(!transportConfig.endpoint||!transportConfig.transport)throw new Error("malformed transport configuration");const transportName=transportConfig.transport;if(["websocket","http_stream","sse","sockjs","webtransport"].indexOf(transportName)<0)throw new Error("unsupported transport name: "+transportName)}}}_setState(newState){if(this.state!==newState){this._reconnecting=!1;const oldState=this.state;return this.state=newState,this.emit("state",{newState:newState,oldState:oldState}),!0}return!1}_isDisconnected(){return this.state===State.Disconnected}_isConnecting(){return this.state===State.Connecting}_isConnected(){return this.state===State.Connected}_nextCommandId(){return++this._commandId}_setNetworkEvents(){if(this._networkEventsSet)return;let eventTarget=null;null!==this._config.networkEventTarget?eventTarget=this._config.networkEventTarget:void 0!==globalThis.addEventListener&&(eventTarget=globalThis),eventTarget&&(eventTarget.addEventListener("offline",(()=>{this._debug("offline event triggered"),this.state!==State.Connected&&this.state!==State.Connecting||(this._disconnect(connectingCodes.transportClosed,"transport closed",!0),this._deviceWentOffline=!0)})),eventTarget.addEventListener("online",(()=>{this._debug("online event triggered"),this.state===State.Connecting&&(this._deviceWentOffline&&!this._transportClosed&&(this._deviceWentOffline=!1,this._transportClosed=!0),this._clearReconnectTimeout(),this._startReconnecting())})),this._networkEventsSet=!0)}_getReconnectDelay(){const delay=backoff(this._reconnectAttempts,this._config.minReconnectDelay,this._config.maxReconnectDelay);return this._reconnectAttempts+=1,delay}_clearOutgoingRequests(){for(const id in this._callbacks)if(this._callbacks.hasOwnProperty(id)){const callbacks=this._callbacks[id];clearTimeout(callbacks.timeout);const errback=callbacks.errback;if(!errback)continue;errback({error:this._createErrorObject(errorCodes.connectionClosed,"connection closed")})}this._callbacks={}}_clearConnectedState(){this._client=null,this._clearServerPingTimeout(),this._clearRefreshTimeout();for(const channel in this._subs){if(!this._subs.hasOwnProperty(channel))continue;const sub=this._subs[channel];sub.state===SubscriptionState.Subscribed&&sub._setSubscribing(subscribingCodes.transportClosed,"transport closed")}for(const channel in this._serverSubs)this._serverSubs.hasOwnProperty(channel)&&this.emit("subscribing",{channel:channel})}_handleWriteError(commands){for(const command of commands){const id=command.id;if(!(id in this._callbacks))continue;const callbacks=this._callbacks[id];clearTimeout(this._callbacks[id].timeout),delete this._callbacks[id];(0,callbacks.errback)({error:this._createErrorObject(errorCodes.transportWriteError,"transport write error")})}}_transportSendCommands(commands){if(!commands.length)return!0;if(!this._transport)return!1;try{this._transport.send(this._codec.encodeCommands(commands),this._session,this._node)}catch(e){return this._debug("error writing commands",e),this._handleWriteError(commands),!1}return!0}_initializeTransport(){let websocket;null!==this._config.websocket?websocket=this._config.websocket:"function"!=typeof globalThis.WebSocket&&"object"!=typeof globalThis.WebSocket||(websocket=globalThis.WebSocket);let sockjs=null;null!==this._config.sockjs?sockjs=this._config.sockjs:void 0!==globalThis.SockJS&&(sockjs=globalThis.SockJS);let eventsource=null;null!==this._config.eventsource?eventsource=this._config.eventsource:void 0!==globalThis.EventSource&&(eventsource=globalThis.EventSource);let fetchFunc=null;null!==this._config.fetch?fetchFunc=this._config.fetch:void 0!==globalThis.fetch&&(fetchFunc=globalThis.fetch);let readableStream=null;if(null!==this._config.readableStream?readableStream=this._config.readableStream:void 0!==globalThis.ReadableStream&&(readableStream=globalThis.ReadableStream),this._emulation){this._currentTransportIndex>=this._transports.length&&(this._triedAllTransports=!0,this._currentTransportIndex=0);let count=0;for(;;){if(count>=this._transports.length)throw new Error("no supported transport found");const transportConfig=this._transports[this._currentTransportIndex],transportName=transportConfig.transport,transportEndpoint=transportConfig.endpoint;if("websocket"===transportName){if(this._debug("trying websocket transport"),this._transport=new WebsocketTransport(transportEndpoint,{websocket:websocket}),!this._transport.supported()){this._debug("websocket transport not available"),this._currentTransportIndex++,count++;continue}}else if("webtransport"===transportName){if(this._debug("trying webtransport transport"),this._transport=new WebtransportTransport(transportEndpoint,{webtransport:globalThis.WebTransport,decoder:this._codec,encoder:this._codec}),!this._transport.supported()){this._debug("webtransport transport not available"),this._currentTransportIndex++,count++;continue}}else if("http_stream"===transportName){if(this._debug("trying http_stream transport"),this._transport=new HttpStreamTransport(transportEndpoint,{fetch:fetchFunc,readableStream:readableStream,emulationEndpoint:this._config.emulationEndpoint,decoder:this._codec,encoder:this._codec}),!this._transport.supported()){this._debug("http_stream transport not available"),this._currentTransportIndex++,count++;continue}}else if("sse"===transportName){if(this._debug("trying sse transport"),this._transport=new SseTransport(transportEndpoint,{eventsource:eventsource,fetch:fetchFunc,emulationEndpoint:this._config.emulationEndpoint}),!this._transport.supported()){this._debug("sse transport not available"),this._currentTransportIndex++,count++;continue}}else{if("sockjs"!==transportName)throw new Error("unknown transport "+transportName);if(this._debug("trying sockjs"),this._transport=new SockjsTransport(transportEndpoint,{sockjs:sockjs,sockjsOptions:this._config.sockjsOptions}),!this._transport.supported()){this._debug("sockjs transport not available"),this._currentTransportIndex++,count++;continue}}break}}else{if(value=this._endpoint,prefix="http",0===value.lastIndexOf(prefix,0))throw new Error("Provide explicit transport endpoints configuration in case of using HTTP (i.e. using array of TransportEndpoint instead of a single string), or use ws(s):// scheme in an endpoint if you aimed using WebSocket transport");if(this._debug("client will use websocket"),this._transport=new WebsocketTransport(this._endpoint,{websocket:websocket}),!this._transport.supported())throw new Error("WebSocket constructor not found, make sure it is available globally or passed as a dependency in Centrifuge options")}var value,prefix;const self=this,transport=this._transport,transportId=this._nextTransportId();self._debug("id of transport",transportId);let wasOpen=!1;const initialCommands=[];if(this._transport.emulation()){const connectCommand=self._sendConnect(!0);initialCommands.push(connectCommand)}this._setNetworkEvents();const initialData=this._codec.encodeCommands(initialCommands);let connectTimeout;this._transportClosed=!1,connectTimeout=setTimeout((function(){transport.close()}),this._config.timeout),this._transport.initialize(this._codecName(),{onOpen:function(){if(connectTimeout&&(clearTimeout(connectTimeout),connectTimeout=null),self._transportId!=transportId)return self._debug("open callback from non-actual transport"),void transport.close();wasOpen=!0,self._debug(transport.subName(),"transport open"),transport.emulation()||(self._transportIsOpen=!0,self._transportWasOpen=!0,self.startBatching(),self._sendConnect(!1),self._sendSubscribeCommands(),self.stopBatching(),self.emit("__centrifuge_debug:connect_frame_sent",{}))},onError:function(e){self._transportId==transportId?self._debug("transport level error",e):self._debug("error callback from non-actual transport")},onClose:function(closeEvent){if(connectTimeout&&(clearTimeout(connectTimeout),connectTimeout=null),self._transportId!=transportId)return void self._debug("close callback from non-actual transport");self._debug(transport.subName(),"transport closed"),self._transportClosed=!0,self._transportIsOpen=!1;let reason="connection closed",needReconnect=!0,code=0;if(closeEvent&&"code"in closeEvent&&closeEvent.code&&(code=closeEvent.code),closeEvent&&closeEvent.reason)try{const advice=JSON.parse(closeEvent.reason);reason=advice.reason,needReconnect=advice.reconnect}catch(e){reason=closeEvent.reason,(code>=3500&&code<4e3||code>=4500&&code<5e3)&&(needReconnect=!1)}code<3e3?(1009===code?(code=disconnectedCodes.messageSizeLimit,reason="message size limit exceeded",needReconnect=!1):(code=connectingCodes.transportClosed,reason="transport closed"),self._emulation&&!self._transportWasOpen&&(self._currentTransportIndex++,self._currentTransportIndex>=self._transports.length&&(self._triedAllTransports=!0,self._currentTransportIndex=0))):self._transportWasOpen=!0,self._isConnecting()&&!wasOpen&&self.emit("error",{type:"transport",error:{code:errorCodes.transportClosed,message:"transport closed"},transport:transport.name()}),self._reconnecting=!1,self._disconnect(code,reason,needReconnect)},onMessage:function(data){self._dataReceived(data)}},initialData),self.emit("__centrifuge_debug:transport_initialized",{})}_sendConnect(skipSending){const connectCommand=this._constructConnectCommand(),self=this;return this._call(connectCommand,skipSending).then((resolveCtx=>{const result=resolveCtx.reply.connect;self._connectResponse(result),resolveCtx.next&&resolveCtx.next()}),(rejectCtx=>{self._connectError(rejectCtx.error),rejectCtx.next&&rejectCtx.next()})),connectCommand}_startReconnecting(){if(this._debug("start reconnecting"),!this._isConnecting())return void this._debug("stop reconnecting: client not in connecting state");if(this._reconnecting)return void this._debug("reconnect already in progress, return from reconnect routine");if(!1===this._transportClosed)return void this._debug("waiting for transport close");this._reconnecting=!0;const emptyToken=""===this._token;if(!(this._refreshRequired||emptyToken&&null!==this._config.getToken))return void(this._config.getData?this._config.getData().then((data=>{this._isConnecting()&&(this._data=data,this._initializeTransport())})).catch((e=>this._handleGetDataError(e))):this._initializeTransport());const self=this;this._getToken().then((function(token){self._isConnecting()&&(null!=token&&null!=token?(self._token=token,self._debug("connection token refreshed"),self._config.getData?self._config.getData().then((function(data){self._isConnecting()&&(self._data=data,self._initializeTransport())})).catch((e=>self._handleGetDataError(e))):self._initializeTransport()):self._failUnauthorized())})).catch((function(e){if(!self._isConnecting())return;if(e instanceof UnauthorizedError)return void self._failUnauthorized();self.emit("error",{type:"connectToken",error:{code:errorCodes.clientConnectToken,message:void 0!==e?e.toString():""}});const delay=self._getReconnectDelay();self._debug("error on getting connection token, reconnect after "+delay+" milliseconds",e),self._reconnecting=!1,self._reconnectTimeout=setTimeout((()=>{self._startReconnecting()}),delay)}))}_handleGetDataError(e){if(e instanceof UnauthorizedError)return void this._failUnauthorized();this.emit("error",{type:"connectData",error:{code:errorCodes.badConfiguration,message:(null==e?void 0:e.toString())||""}});const delay=this._getReconnectDelay();this._debug("error on getting connect data, reconnect after "+delay+" milliseconds",e),this._reconnecting=!1,this._reconnectTimeout=setTimeout((()=>{this._startReconnecting()}),delay)}_connectError(err){this.state===State.Connecting&&(109===err.code&&(this._refreshRequired=!0),err.code<100||!0===err.temporary||109===err.code?(this.emit("error",{type:"connect",error:err}),this._debug("closing transport due to connect error"),this._disconnect(err.code,err.message,!0)):this._disconnect(err.code,err.message,!1))}_scheduleReconnect(){if(!this._isConnecting())return;let isInitialHandshake=!1;!this._emulation||this._transportWasOpen||this._triedAllTransports||(isInitialHandshake=!0);let delay=this._getReconnectDelay();isInitialHandshake&&(delay=0),this._debug("reconnect after "+delay+" milliseconds"),this._clearReconnectTimeout(),this._reconnectTimeout=setTimeout((()=>{this._startReconnecting()}),delay)}_constructConnectCommand(){const req={};this._token&&(req.token=this._token),this._data&&(req.data=this._data),this._config.name&&(req.name=this._config.name),this._config.version&&(req.version=this._config.version),Object.keys(this._config.headers).length>0&&(req.headers=this._config.headers);const subs={};let hasSubs=!1;for(const channel in this._serverSubs)if(this._serverSubs.hasOwnProperty(channel)&&this._serverSubs[channel].recoverable){hasSubs=!0;const sub={recover:!0};this._serverSubs[channel].offset&&(sub.offset=this._serverSubs[channel].offset),this._serverSubs[channel].epoch&&(sub.epoch=this._serverSubs[channel].epoch),subs[channel]=sub}return hasSubs&&(req.subs=subs),{connect:req}}_getHistoryRequest(channel,options){const req={channel:channel};return void 0!==options&&(options.since&&(req.since={offset:options.since.offset},options.since.epoch&&(req.since.epoch=options.since.epoch)),void 0!==options.limit&&(req.limit=options.limit),!0===options.reverse&&(req.reverse=!0)),req}_methodCall(){return this._isConnected()?Promise.resolve():new Promise(((res,rej)=>{const timeout=setTimeout((function(){rej({code:errorCodes.timeout,message:"timeout"})}),this._config.timeout);this._promises[this._nextPromiseId()]={timeout:timeout,resolve:res,reject:rej}}))}_callPromise(cmd,resultCB){return new Promise(((resolve,reject)=>{this._call(cmd,!1).then((resolveCtx=>{var _a;const result=resultCB(resolveCtx.reply);resolve(result),null===(_a=resolveCtx.next)||void 0===_a||_a.call(resolveCtx)}),(rejectCtx=>{var _a;reject(rejectCtx.error),null===(_a=rejectCtx.next)||void 0===_a||_a.call(rejectCtx)}))}))}_dataReceived(data){this._serverPing>0&&this._waitServerPing();const replies=this._codec.decodeReplies(data);this._dispatchPromise=this._dispatchPromise.then((()=>{let finishDispatch;this._dispatchPromise=new Promise((resolve=>{finishDispatch=resolve})),this._dispatchSynchronized(replies,finishDispatch)}))}_dispatchSynchronized(replies,finishDispatch){let p=Promise.resolve();for(const i in replies)replies.hasOwnProperty(i)&&(p=p.then((()=>this._dispatchReply(replies[i]))));p=p.then((()=>{finishDispatch()}))}_dispatchReply(reply){let next;const p=new Promise((resolve=>{next=resolve}));if(null==reply)return this._debug("dispatch: got undefined or null reply"),next(),p;const id=reply.id;return id&&id>0?this._handleReply(reply,next):reply.push?this._handlePush(reply.push,next):this._handleServerPing(next),p}_call(cmd,skipSending){return new Promise(((resolve,reject)=>{cmd.id=this._nextCommandId(),this._registerCall(cmd.id,resolve,reject),skipSending||this._addCommand(cmd)}))}_startConnecting(){this._debug("start connecting"),this._setState(State.Connecting)&&this.emit("connecting",{code:connectingCodes.connectCalled,reason:"connect called"}),this._client=null,this._startReconnecting()}_disconnect(code,reason,reconnect){if(this._isDisconnected())return;this._transportIsOpen=!1;const previousState=this.state;this._reconnecting=!1;const ctx={code:code,reason:reason};let needEvent=!1;if(reconnect?needEvent=this._setState(State.Connecting):(needEvent=this._setState(State.Disconnected),this._rejectPromises({code:errorCodes.clientDisconnected,message:"disconnected"})),this._clearOutgoingRequests(),previousState===State.Connecting&&this._clearReconnectTimeout(),previousState===State.Connected&&this._clearConnectedState(),needEvent&&(this._isConnecting()?this.emit("connecting",ctx):this.emit("disconnected",ctx)),this._transport){this._debug("closing existing transport");const transport=this._transport;this._transport=null,transport.close(),this._transportClosed=!0,this._nextTransportId()}else this._debug("no transport to close");this._scheduleReconnect()}_failUnauthorized(){this._disconnect(disconnectedCodes.unauthorized,"unauthorized",!1)}_getToken(){return this._debug("get connection token"),this._config.getToken?this._config.getToken({}):(this.emit("error",{type:"configuration",error:{code:errorCodes.badConfiguration,message:"token expired but no getToken function set in the configuration"}}),Promise.reject(new UnauthorizedError("")))}_refresh(){const clientId=this._client,self=this;this._getToken().then((function(token){if(clientId!==self._client)return;if(!token)return void self._failUnauthorized();if(self._token=token,self._debug("connection token refreshed"),!self._isConnected())return;const cmd={refresh:{token:self._token}};self._call(cmd,!1).then((resolveCtx=>{const result=resolveCtx.reply.refresh;self._refreshResponse(result),resolveCtx.next&&resolveCtx.next()}),(rejectCtx=>{self._refreshError(rejectCtx.error),rejectCtx.next&&rejectCtx.next()}))})).catch((function(e){self._isConnected()&&(e instanceof UnauthorizedError?self._failUnauthorized():(self.emit("error",{type:"refreshToken",error:{code:errorCodes.clientRefreshToken,message:void 0!==e?e.toString():""}}),self._refreshTimeout=setTimeout((()=>self._refresh()),self._getRefreshRetryDelay())))}))}_refreshError(err){err.code<100||!0===err.temporary?(this.emit("error",{type:"refresh",error:err}),this._refreshTimeout=setTimeout((()=>this._refresh()),this._getRefreshRetryDelay())):this._disconnect(err.code,err.message,!1)}_getRefreshRetryDelay(){return backoff(0,5e3,1e4)}_refreshResponse(result){this._refreshTimeout&&(clearTimeout(this._refreshTimeout),this._refreshTimeout=null),result.expires&&(this._client=result.client,this._refreshTimeout=setTimeout((()=>this._refresh()),ttlMilliseconds(result.ttl)))}_removeSubscription(sub){null!==sub&&delete this._subs[sub.channel]}_unsubscribe(sub){if(!this._transportIsOpen)return Promise.resolve();const cmd={unsubscribe:{channel:sub.channel}},self=this;return new Promise(((resolve,_)=>{this._call(cmd,!1).then((resolveCtx=>{resolve(),resolveCtx.next&&resolveCtx.next()}),(rejectCtx=>{resolve(),rejectCtx.next&&rejectCtx.next(),self._disconnect(connectingCodes.unsubscribeError,"unsubscribe error",!0)}))}))}_getSub(channel,id){if(id&&id>0){for(const ch in this._subs)if(this._subs.hasOwnProperty(ch)){const sub=this._subs[ch];if(sub._id===id)return sub}return null}const sub=this._subs[channel];return sub||null}_isServerSub(channel){return void 0!==this._serverSubs[channel]}_sendSubscribeCommands(){const commands=[];for(const channel in this._subs){if(!this._subs.hasOwnProperty(channel))continue;const sub=this._subs[channel];if(!0!==sub._inflight&&sub.state===SubscriptionState.Subscribing){const cmd=sub._subscribe();cmd&&commands.push(cmd)}}return commands}_connectResponse(result){if(this._transportIsOpen=!0,this._transportWasOpen=!0,this._reconnectAttempts=0,this._refreshRequired=!1,this._isConnected())return;this._client=result.client,this._setState(State.Connected),this._refreshTimeout&&clearTimeout(this._refreshTimeout),result.expires&&(this._refreshTimeout=setTimeout((()=>this._refresh()),ttlMilliseconds(result.ttl))),this._session=result.session,this._node=result.node,this.startBatching(),this._sendSubscribeCommands(),this.stopBatching();const ctx={client:result.client,transport:this._transport.subName()};result.data&&(ctx.data=result.data),this.emit("connected",ctx),this._resolvePromises(),this._processServerSubs(result.subs||{}),result.ping&&result.ping>0?(this._serverPing=1e3*result.ping,this._sendPong=!0===result.pong,this._waitServerPing()):this._serverPing=0}_processServerSubs(subs){for(const channel in subs){if(!subs.hasOwnProperty(channel))continue;const sub=subs[channel];this._serverSubs[channel]={offset:sub.offset,epoch:sub.epoch,recoverable:sub.recoverable||!1};const subCtx=this._getSubscribeContext(channel,sub);this.emit("subscribed",subCtx)}for(const channel in subs){if(!subs.hasOwnProperty(channel))continue;const sub=subs[channel];if(sub.recovered){const pubs=sub.publications;if(pubs&&pubs.length>0)for(const i in pubs)pubs.hasOwnProperty(i)&&this._handlePublication(channel,pubs[i])}}for(const channel in this._serverSubs)this._serverSubs.hasOwnProperty(channel)&&(subs[channel]||(this.emit("unsubscribed",{channel:channel}),delete this._serverSubs[channel]))}_clearRefreshTimeout(){null!==this._refreshTimeout&&(clearTimeout(this._refreshTimeout),this._refreshTimeout=null)}_clearReconnectTimeout(){null!==this._reconnectTimeout&&(clearTimeout(this._reconnectTimeout),this._reconnectTimeout=null)}_clearServerPingTimeout(){null!==this._serverPingTimeout&&(clearTimeout(this._serverPingTimeout),this._serverPingTimeout=null)}_waitServerPing(){0!==this._config.maxServerPingDelay&&this._isConnected()&&(this._clearServerPingTimeout(),this._serverPingTimeout=setTimeout((()=>{this._isConnected()&&this._disconnect(connectingCodes.noPing,"no ping",!0)}),this._serverPing+this._config.maxServerPingDelay))}_getSubscribeContext(channel,result){const ctx={channel:channel,positioned:!1,recoverable:!1,wasRecovering:!1,recovered:!1,hasRecoveredPublications:!1};result.recovered&&(ctx.recovered=!0),result.positioned&&(ctx.positioned=!0),result.recoverable&&(ctx.recoverable=!0),result.was_recovering&&(ctx.wasRecovering=!0);let epoch="";"epoch"in result&&(epoch=result.epoch);let offset=0;return"offset"in result&&(offset=result.offset),(ctx.positioned||ctx.recoverable)&&(ctx.streamPosition={offset:offset,epoch:epoch}),Array.isArray(result.publications)&&result.publications.length>0&&(ctx.hasRecoveredPublications=!0),result.data&&(ctx.data=result.data),ctx}_handleReply(reply,next){const id=reply.id;if(!(id in this._callbacks))return void next();const callbacks=this._callbacks[id];if(clearTimeout(this._callbacks[id].timeout),delete this._callbacks[id],"error"in(data=reply)&&null!==data.error){const errback=callbacks.errback;if(!errback)return void next();errback({error:{code:reply.error.code,message:reply.error.message||"",temporary:reply.error.temporary||!1},next:next})}else{const callback=callbacks.callback;if(!callback)return;callback({reply:reply,next:next})}var data}_handleJoin(channel,join,id){const sub=this._getSub(channel,id);if(sub||!channel)sub._handleJoin(join);else if(this._isServerSub(channel)){const ctx={channel:channel,info:this._getJoinLeaveContext(join.info)};this.emit("join",ctx)}}_handleLeave(channel,leave,id){const sub=this._getSub(channel,id);if(sub||!channel)sub._handleLeave(leave);else if(this._isServerSub(channel)){const ctx={channel:channel,info:this._getJoinLeaveContext(leave.info)};this.emit("leave",ctx)}}_handleUnsubscribe(channel,unsubscribe){const sub=this._getSub(channel,0);sub||!channel?unsubscribe.code<2500?sub._setUnsubscribed(unsubscribe.code,unsubscribe.reason,!1):sub._setSubscribing(unsubscribe.code,unsubscribe.reason):this._isServerSub(channel)&&(delete this._serverSubs[channel],this.emit("unsubscribed",{channel:channel}))}_handleSubscribe(channel,sub){this._serverSubs[channel]={offset:sub.offset,epoch:sub.epoch,recoverable:sub.recoverable||!1},this.emit("subscribed",this._getSubscribeContext(channel,sub))}_handleDisconnect(disconnect){const code=disconnect.code;let reconnect=!0;(code>=3500&&code<4e3||code>=4500&&code<5e3)&&(reconnect=!1),this._disconnect(code,disconnect.reason,reconnect)}_getPublicationContext(channel,pub){const ctx={channel:channel,data:pub.data};return pub.offset&&(ctx.offset=pub.offset),pub.info&&(ctx.info=this._getJoinLeaveContext(pub.info)),pub.tags&&(ctx.tags=pub.tags),ctx}_getJoinLeaveContext(clientInfo){const info={client:clientInfo.client,user:clientInfo.user},connInfo=clientInfo.conn_info;connInfo&&(info.connInfo=connInfo);const chanInfo=clientInfo.chan_info;return chanInfo&&(info.chanInfo=chanInfo),info}_handlePublication(channel,pub,id){const sub=this._getSub(channel,id);if(sub||!channel)sub._handlePublication(pub);else if(this._isServerSub(channel)){const ctx=this._getPublicationContext(channel,pub);this.emit("publication",ctx),void 0!==pub.offset&&(this._serverSubs[channel].offset=pub.offset)}}_handleMessage(message){this.emit("message",{data:message.data})}_handleServerPing(next){if(this._sendPong){const cmd={};this._transportSendCommands([cmd])}next()}_handlePush(data,next){const channel=data.channel,id=data.id;data.pub?this._handlePublication(channel,data.pub,id):data.message?this._handleMessage(data.message):data.join?this._handleJoin(channel,data.join,id):data.leave?this._handleLeave(channel,data.leave,id):data.unsubscribe?this._handleUnsubscribe(channel,data.unsubscribe):data.subscribe?this._handleSubscribe(channel,data.subscribe):data.disconnect&&this._handleDisconnect(data.disconnect),next()}_flush(){const commands=this._commands.slice(0);this._commands=[],this._transportSendCommands(commands)}_createErrorObject(code,message,temporary){const errObject={code:code,message:message};return temporary&&(errObject.temporary=!0),errObject}_registerCall(id,callback,errback){this._callbacks[id]={callback:callback,errback:errback,timeout:null},this._callbacks[id].timeout=setTimeout((()=>{delete this._callbacks[id],isFunction(errback)&&errback({error:this._createErrorObject(errorCodes.timeout,"timeout")})}),this._config.timeout)}_addCommand(command){this._batching?this._commands.push(command):this._transportSendCommands([command])}_nextPromiseId(){return++this._promiseId}_nextTransportId(){return++this._transportId}_resolvePromises(){for(const id in this._promises)this._promises.hasOwnProperty(id)&&(this._promises[id].timeout&&clearTimeout(this._promises[id].timeout),this._promises[id].resolve(),delete this._promises[id])}_rejectPromises(err){for(const id in this._promises)this._promises.hasOwnProperty(id)&&(this._promises[id].timeout&&clearTimeout(this._promises[id].timeout),this._promises[id].reject(err),delete this._promises[id])}}_exports.Centrifuge=Centrifuge,Centrifuge.SubscriptionState=SubscriptionState,Centrifuge.State=State,Centrifuge.UnauthorizedError=UnauthorizedError}));

//# sourceMappingURL=centrifuge-lazy.min.js.map